<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>FortuneAI式 17タイプ診断</title>

  <style>
    :root{
      --bg0:#070b1a;
      --bg1:#0b1231;

      --card: rgba(255,255,255,.06);
      --line: rgba(255,255,255,.14);
      --text:#eaf0ff;

      --accent1:#7c4dff;
      --accent2:#cfa76e;
      --accent3:#43d3ff;

      --shadow: 0 18px 60px rgba(0,0,0,.38);
      --r: 18px;

      --safeBottom: env(safe-area-inset-bottom, 0px);
      --safeTop: env(safe-area-inset-top, 0px);

      /* JSで実測して入れる（質問画面のスクロール撲滅用） */
      --headerH: 110px;
      --bottomH: 86px;

      /* ★重要：スマホで右予約すると文字が潰れて「ぐちゃぐちゃ」になるのでデフォ0 */
      --mapReserve: 0px;
    }

    *{box-sizing:border-box}
    html, body{height:100%; overscroll-behavior:none; -webkit-text-size-adjust:100%;}
    body{
      margin:0;
      color:var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Sans", "Yu Gothic", sans-serif;
      background:
        radial-gradient(1200px 650px at 15% 5%, color-mix(in oklab, var(--accent1) 35%, transparent), transparent 62%),
        radial-gradient(900px 540px at 85% 25%, color-mix(in oklab, var(--accent2) 26%, transparent), transparent 62%),
        radial-gradient(900px 540px at 65% 85%, color-mix(in oklab, var(--accent3) 18%, transparent), transparent 62%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
      touch-action: pan-y;
    }

    /* 質問画面だけ「ページスクロールなし」 */
    body.isQuestions{
      height: 100svh;
      overflow: hidden;
      touch-action: manipulation;
    }

    input, select, textarea{max-width:100%;}
    /* iOSでフォームが変に伸びる/ズームするのを抑える */
    input, select, textarea{ font-size:16px; }

    .wrap{
      max-width:1180px;
      margin:0 auto;
      padding: 14px 14px calc(96px + var(--safeBottom));
    }

    /* 質問画面は viewport に収める（縦スクロール禁止） */
    body.isQuestions .wrap{
      height: calc(100svh - var(--headerH) - var(--bottomH));
      padding: 10px 14px 0;
      padding-right: 14px;           /* ★スマホは右予約しない（崩壊原因） */
      overflow: hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    /* タブレット以上だけ右にミニマップ分の余白を確保（被りゼロ） */
    @media (min-width: 720px){
      :root{ --mapReserve: 170px; }
      body.isQuestions .wrap{ padding-right: calc(14px + var(--mapReserve)); }
    }

    /* ===== Header (スマホ2段化で被りゼロ) ===== */
    .topbar{
      position:sticky; top:0; z-index:80;
      padding-top: var(--safeTop);
      background: linear-gradient(180deg, rgba(7,11,26,.94), rgba(11,18,49,.70));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .topbarInner{
      max-width:1180px;
      margin:0 auto;
      padding: 12px 14px 12px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      min-width:0;
    }
    .brand{display:flex; gap:12px; align-items:center; min-width:0;}
    .orb{
      width:44px; height:44px; border-radius:999px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.92), rgba(255,255,255,.10) 42%, rgba(124,77,255,.28) 72%, rgba(207,167,110,.18));
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 0 26px color-mix(in oklab, var(--accent1) 28%, transparent),
                  0 0 18px color-mix(in oklab, var(--accent2) 18%, transparent);
      flex: 0 0 auto;
    }
    .title{font-size:14px; letter-spacing:.06em; margin:0; line-height:1.2;}
    .subtitle{
      font-size:12px; opacity:.86; margin-top:4px; line-height:1.35;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      max-width: min(560px, 58vw);
    }

    .meter{
      width: min(520px, 52vw);
      min-width: 220px;
      display:flex; align-items:center; gap:10px;
      justify-content:flex-end;
      min-width:0;
    }
    .meterText{font-size:12px; opacity:.92; min-width:72px; text-align:right; white-space:nowrap;}
    .waterBar{
      position:relative; height:16px; width:100%;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      overflow:hidden;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.08);
    }
    .waterFill{
      position:absolute; inset:0 auto 0 0; width:0%;
      border-radius:999px;
      background:
        linear-gradient(90deg,
          color-mix(in oklab, var(--accent1) 90%, white 10%),
          color-mix(in oklab, var(--accent3) 70%, white 10%),
          color-mix(in oklab, var(--accent2) 85%, white 10%));
      filter:saturate(1.05);
      transition: width .30s ease;
      overflow:hidden;
    }
    /* 水面のゆらぎ */
    .waterFill::before{
      content:"";
      position:absolute; inset:-10px -60px -10px -60px;
      background:
        radial-gradient(18px 10px at 20px 18px, rgba(255,255,255,.34), rgba(255,255,255,0) 70%),
        radial-gradient(22px 12px at 60px 26px, rgba(255,255,255,.22), rgba(255,255,255,0) 72%),
        radial-gradient(18px 10px at 100px 18px, rgba(255,255,255,.30), rgba(255,255,255,0) 70%);
      opacity:.50;
      animation: waveMove 2.4s linear infinite;
      mix-blend-mode: screen;
      pointer-events:none;
    }
    @keyframes waveMove{0%{transform:translateX(0)}100%{transform:translateX(110px)}}
    /* キラキラ（ゲージ内） */
    .waterFill .sparkles{
      position:absolute; inset:-30px -60px -30px -60px;
      background:
        radial-gradient(2px 2px at 14% 44%, rgba(255,255,255,.95), rgba(255,255,255,0) 60%),
        radial-gradient(1.5px 1.5px at 28% 62%, rgba(255,255,255,.88), rgba(255,255,255,0) 60%),
        radial-gradient(2px 2px at 42% 32%, rgba(255,255,255,.82), rgba(255,255,255,0) 60%),
        radial-gradient(1.2px 1.2px at 58% 52%, rgba(255,255,255,.80), rgba(255,255,255,0) 60%),
        radial-gradient(2px 2px at 72% 38%, rgba(255,255,255,.90), rgba(255,255,255,0) 60%),
        radial-gradient(1.6px 1.6px at 84% 58%, rgba(255,255,255,.84), rgba(255,255,255,0) 60%);
      opacity:.55;
      animation: sparkleDrift 3.2s linear infinite;
      mix-blend-mode: screen;
      pointer-events:none;
    }
    @keyframes sparkleDrift{
      0%{ transform: translateX(-20px) translateY(0px); filter: blur(.0px); }
      50%{ transform: translateX(20px) translateY(-6px); filter: blur(.2px); }
      100%{ transform: translateX(60px) translateY(0px); filter: blur(.0px); }
    }

    @media(max-width:560px){
      .topbarInner{flex-direction:column; align-items:stretch; gap:10px;}
      .brand{width:100%;}
      .subtitle{max-width:100%;}
      .meter{width:100%; min-width:0; justify-content:space-between;}
      .meterText{min-width:64px;}
    }

    .card{
      margin-top:14px;
      border:1px solid var(--line);
      background: var(--card);
      border-radius: var(--r);
      padding: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
    }

    /* 質問画面は外側カードを“器”にして高さ固定（スクロール禁止） */
    body.isQuestions #viewQuestions.card{
      flex: 1;
      min-height:0;
      margin-top: 10px;
      padding: 0;
      background: transparent;
      border: none;
      box-shadow: none;
      backdrop-filter: none;
      display:flex;
    }

    .h1{font-size:18px; margin:0 0 8px; letter-spacing:.05em; line-height:1.25;}
    .lead{margin:0; font-size:13px; opacity:.88; line-height:1.75;}
    .muted{opacity:.84}
    .small{font-size:12px}
    .sep{height:1px; background: rgba(255,255,255,.10); margin: 12px 0;}

    .pillRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.04);
      font-size:12px; opacity:.95;
    }

    .btnRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:14px; align-items:center;}
    .btn{
      appearance:none; border:none;
      padding: 12px 14px; border-radius: 14px;
      cursor:pointer; color: var(--text);
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      transition: transform .08s ease, border-color .2s ease, background .2s ease, filter .2s ease;
      user-select:none; -webkit-tap-highlight-color: transparent;
      white-space: nowrap;
    }
    .btn:hover{border-color: rgba(255,255,255,.22);}
    .btn:active{transform: translateY(1px) scale(.995);}
    .btn.primary{
      background: linear-gradient(90deg,
        color-mix(in oklab, var(--accent1) 85%, black 10%),
        color-mix(in oklab, var(--accent2) 80%, black 10%));
      border-color: rgba(255,255,255,.18);
      filter: saturate(1.08);
    }
    .btn.ghost{ background: rgba(255,255,255,.03); }
    .btn.danger{ background: rgba(255,107,107,.12); border-color: rgba(255,107,107,.40); }
    .btn:disabled{opacity:.45; cursor:not-allowed;}

    .toast{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      font-size: 12px;
      line-height:1.6;
      opacity:.92;
      white-space:pre-line;
    }
    .toast.ok{border-color: rgba(65,209,138,.35); background: rgba(65,209,138,.08);}
    .toast.bad{border-color: rgba(255,107,107,.35); background: rgba(255,107,107,.08);}
    .toast.warn{border-color: rgba(255,204,102,.35); background: rgba(255,204,102,.08);}

    label{display:block; font-size:12px; opacity:.88; margin-bottom:6px;}
    .field{
      width:100%;
      padding: 12px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline:none;
      min-width:0;
      display:block;
    }
    input[type="date"].field{
      min-width:0;
      width:100%;
      max-width:100%;
      display:block;
    }
    .field:focus{
      border-color: color-mix(in oklab, var(--accent2) 55%, white 0%);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent2) 18%, transparent);
    }
    .err{color:#ff6b6b; font-size:12px; margin-top:6px; line-height:1.5; display:none;}

    /* ===== Question Card ===== */
    .qCard{
      flex: 1;
      min-height:0;
      padding: 14px;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(700px 280px at 10% 10%, color-mix(in oklab, var(--accent1) 18%, transparent), transparent 55%),
        radial-gradient(650px 260px at 90% 35%, color-mix(in oklab, var(--accent2) 12%, transparent), transparent 60%),
        rgba(255,255,255,.04);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      display:flex;
      flex-direction:column;
      gap: 10px;
      overflow:hidden;
    }

    .qTop{display:flex; align-items:flex-start; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .qMeta{display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:12px; opacity:.92;}
    .chip{
      display:inline-flex; gap:8px; align-items:center;
      padding: 6px 10px; border-radius:999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      white-space:nowrap;
    }
    .chapterBadge{
      border-color: color-mix(in oklab, var(--accent1) 25%, rgba(255,255,255,.14));
      background: color-mix(in oklab, var(--accent1) 12%, rgba(255,255,255,.04));
    }

    .qText{
      margin: 0;
      font-size: 15px;
      letter-spacing:.02em;
      line-height:1.7;
      /* ぐちゃぐちゃ防止：単語単位で折り返し */
      word-break: normal;
      overflow-wrap: anywhere;
    }

    /* qTag（S+等）を非表示（データ保持） */
    #qTagChip{display:none !important;}

    .scaleWrap{
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.14);
      padding: 12px 12px;
    }

    /* ★縦に潰れても崩れにくいよう grid 化 */
    .scaleHead{
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 8px;
      align-items:center;
      font-size:12px;
      opacity:.92;
    }
    .scaleHead span:first-child{ text-align:left; }
    .scaleHead span:last-child{ text-align:right; }

    .valuePill{
      min-width: 44px; text-align:center; font-weight:700; font-size:13px;
      padding: 6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      box-shadow: 0 0 0 3px rgba(0,0,0,.10) inset;
    }

    .range{
      margin-top: 10px;
      width: 100%;
      -webkit-appearance: none;
      appearance: none;
      height: 10px;
      border-radius: 999px;
      outline:none;
      border: 1px solid rgba(255,255,255,.14);
      background:
        linear-gradient(90deg,
          var(--fillColor) 0%,
          var(--fillColor) var(--fillPct),
          rgba(255,255,255,.10) var(--fillPct),
          rgba(255,255,255,.10) 100%);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.10);
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .range::-webkit-slider-runnable-track{height:10px; border-radius:999px;}
    .range::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none;
      width:26px; height:26px; border-radius:999px;
      border: 1px solid rgba(255,255,255,.26);
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.96), rgba(255,255,255,.20) 40%, color-mix(in oklab, var(--fillColor) 72%, rgba(0,0,0,.10)) 76%),
        radial-gradient(circle at 70% 70%, rgba(255,255,255,.16), rgba(255,255,255,0) 62%);
      box-shadow:
        0 0 18px color-mix(in oklab, var(--fillColor) 40%, transparent),
        0 0 12px rgba(0,0,0,.25);
      margin-top: -8px;
      transform: scale(var(--thumbScale, 1));
      transition: transform .10s linear;
    }
    .range::-moz-range-track{
      height: 10px; border-radius:999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.14);
    }
    .range::-moz-range-thumb{
      width:26px; height:26px; border-radius:999px;
      border: 1px solid rgba(255,255,255,.26);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.96), rgba(255,255,255,.20) 40%, color-mix(in oklab, var(--fillColor) 72%, rgba(0,0,0,.10)) 76%);
      box-shadow: 0 0 18px color-mix(in oklab, var(--fillColor) 40%, transparent), 0 0 12px rgba(0,0,0,.25);
      transform: scale(var(--thumbScale, 1));
      transition: transform .10s linear;
    }

    .tickRow{margin-top:10px; display:grid; grid-template-columns:repeat(7, 1fr); gap:6px;}
    .tickBtn{
      appearance:none; border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color: rgba(234,240,255,.88);
      border-radius: 12px;
      padding: 9px 0;
      font-size: 12px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .08s ease, border-color .2s ease, background .2s ease;
    }
    .tickBtn:active{ transform: translateY(1px) scale(.995); }
    .tickBtn.on{
      border-color: color-mix(in oklab, var(--fillColor) 55%, rgba(255,255,255,.12));
      background: color-mix(in oklab, var(--fillColor) 18%, rgba(255,255,255,.03));
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--fillColor) 14%, transparent);
      color: rgba(234,240,255,.96);
    }

    /* 質問画面のボタン行：押しやすくしつつ省スペース */
    body.isQuestions .qCard .btnRow{ margin-top: 0; }
    body.isQuestions #btnResetFromQuestions{
      padding: 9px 10px;             /* ★小さく */
      font-size: 12px;               /* ★小さく */
      border-radius: 12px;
      max-width: 240px;
    }

    /* ===== Bottom Nav ===== */
    .bottomNav{
      position: fixed; left:0; right:0; bottom:0; z-index:90;
      padding: 10px 12px calc(10px + var(--safeBottom));
      background: linear-gradient(180deg, rgba(7,11,26,.10), rgba(7,11,26,.86));
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,.08);
    }
    .bottomNavInner{
      max-width:1180px; margin:0 auto;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }

    /* ===== Mini Map (常時表示) ===== */
    .miniMapFloat{
      position: fixed;
      right: 12px;
      /* ★bottomNavの上に配置（ボタンと被りにくい） */
      bottom: calc(var(--bottomH) + 12px);
      z-index: 95;
      width: 164px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,14,36,.55);
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      backdrop-filter: blur(14px);
      overflow:hidden;
      padding: 10px;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    .miniMapFloat:active{ transform: translateY(1px); }
    .miniMapHead{
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      font-size:12px; opacity:.92;
      margin-bottom:8px;
    }
    .miniMapHint{font-size:11px; opacity:.70; margin-top:6px; text-align:center;}

    /* 小さい端末はミニマップを少し縮めて圧迫を減らす */
    @media(max-width:420px){
      .miniMapFloat{ width: 150px; right: 10px; padding: 9px; }
      .miniMapHint{ display:none; }
    }

    /* ===== Modal ===== */
    .modalBack{
      position: fixed; inset:0; z-index:200;
      background: rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center;
      padding: 18px;
    }
    .modal{
      width: min(760px, 96vw);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.16);
      background:
        radial-gradient(600px 240px at 20% 20%, color-mix(in oklab, var(--accent1) 22%, transparent), transparent 60%),
        radial-gradient(600px 240px at 80% 35%, color-mix(in oklab, var(--accent2) 16%, transparent), transparent 62%),
        rgba(10,14,36,.80);
      box-shadow: 0 18px 70px rgba(0,0,0,.55);
      padding: 18px;
      backdrop-filter: blur(14px);
      position:relative;
      overflow:hidden;
      max-height: calc(100svh - 26px);
      overflow:auto;
    }
    .modalGlow{
      position:absolute; inset:-60px -80px;
      background:
        radial-gradient(120px 80px at 20% 30%, rgba(255,255,255,.14), rgba(255,255,255,0) 70%),
        radial-gradient(120px 80px at 70% 50%, rgba(255,255,255,.10), rgba(255,255,255,0) 70%);
      animation: modalFloat 3.6s ease-in-out infinite;
      pointer-events:none;
    }
    @keyframes modalFloat{
      0%,100%{ transform: translateY(0px); opacity:.9; }
      50%{ transform: translateY(10px); opacity:1; }
    }
    .modalTitle{margin:0; font-size:16px; letter-spacing:.06em;}
    .modalBody{margin-top:10px; font-size:13px; line-height:1.8; opacity:.92;}
    .rewardRow{margin-top:12px; display:grid; grid-template-columns:1fr 1fr; gap:10px;}
    .reward{
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      padding: 10px;
      font-size:12px;
      line-height:1.6;
    }

    /* ===== Ascent Map (詳細) ===== */
    .ascentWrap{
      margin-top: 12px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      padding: 10px;
      overflow:hidden;
      position:relative;
    }
    .ascentCaption{
      margin-top:10px;
      font-size:12px;
      line-height:1.6;
      color: rgba(234,240,255,.88);
    }
    #ascentPathProg{transition: stroke-dashoffset .38s ease;}
    .ascentPulse{animation: ascentPulse .9s ease-out 1; transform-origin:center;}
    @keyframes ascentPulse{
      0%{ transform: scale(1); }
      40%{ transform: scale(1.16); }
      100%{ transform: scale(1); }
    }
    .floaty{animation: floaty 2.8s ease-in-out infinite;}
    @keyframes floaty{0%,100%{transform:translateY(0)}50%{transform:translateY(4px)}}

    /* 章クリア：全体フラッシュ */
    .chapterFlash{
      position: fixed; inset:0; z-index:150;
      pointer-events:none;
      opacity:0;
      background:
        radial-gradient(800px 420px at 50% 35%, color-mix(in oklab, var(--accent3) 28%, transparent), transparent 68%),
        radial-gradient(900px 520px at 50% 80%, color-mix(in oklab, var(--accent2) 18%, transparent), transparent 70%),
        rgba(255,255,255,.02);
      transition: opacity .42s ease;
    }
    .chapterFlash.on{opacity:1;}

    [hidden]{display:none !important;}
    .footer{text-align:center; margin-top:18px; font-size:12px; opacity:.78;}

    /* 低い画面（SE等）でさらに詰めて「縦スクロールゼロ」を維持 */
    @media (max-height: 740px){
      body.isQuestions .qCard{ padding: 12px; gap: 8px; }
      .qText{ font-size: 14px; line-height: 1.55; }
      .tickBtn{ padding: 8px 0; }
      .scaleWrap{ padding: 10px 10px; }
      body.isQuestions #btnResetFromQuestions{ padding: 8px 9px; }
    }
  </style>
</head>

<body>
  <div class="chapterFlash" id="chapterFlash" aria-hidden="true"></div>

  <header class="topbar" id="topbar">
    <div class="topbarInner">
      <div class="brand">
        <div class="orb" aria-hidden="true"></div>
        <div style="min-width:0;">
          <h1 class="title">FortuneAI式 17タイプ診断</h1>
          <div class="subtitle" id="topSubtitle">100問×7段階スライダー。神秘の巡礼路で上昇</div>
        </div>
      </div>

      <div class="meter">
        <div class="waterBar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
          <div class="waterFill" id="waterFill">
            <div class="sparkles" aria-hidden="true"></div>
          </div>
        </div>
        <div class="meterText" id="meterText">0 / 100</div>
      </div>
    </div>
  </header>

  <!-- ミニマップ常時表示（質問画面でのみ表示） -->
  <div class="miniMapFloat" id="miniMapBtn" style="display:none;" role="button" aria-label="巡礼路（詳細）">
    <div class="miniMapHead">
      <div>巡礼路</div>
      <div><strong id="miniPct">0%</strong></div>
    </div>
    <svg id="miniSvg" viewBox="0 0 320 220" width="100%" height="120" aria-hidden="true">
      <defs>
        <linearGradient id="miniStroke" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" stop-color="var(--accent1)"/>
          <stop offset="55%" stop-color="var(--accent3)"/>
          <stop offset="100%" stop-color="var(--accent2)"/>
        </linearGradient>
        <filter id="miniGlow">
          <feGaussianBlur stdDeviation="2.0" result="b"/>
          <feMerge>
            <feMergeNode in="b"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>
      <path id="miniPathBase"
        d="M42 190
           C 72 176, 88 172, 106 160
           C 126 146, 120 128, 140 118
           C 158 109, 166 128, 184 112
           C 202 96, 180 78, 200 68
           C 224 56, 236 84, 258 58
           C 274 38, 230 32, 196 40
           C 172 46, 168 34, 160 24"
        fill="none" stroke="rgba(255,255,255,.14)" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/>
      <path id="miniPathProg"
        d="M42 190
           C 72 176, 88 172, 106 160
           C 126 146, 120 128, 140 118
           C 158 109, 166 128, 184 112
           C 202 96, 180 78, 200 68
           C 224 56, 236 84, 258 58
           C 274 38, 230 32, 196 40
           C 172 46, 168 34, 160 24"
        fill="none" stroke="url(#miniStroke)" stroke-width="6" stroke-linecap="round" stroke-linejoin="round" filter="url(#miniGlow)"/>
      <g id="miniMarker" filter="url(#miniGlow)">
        <circle id="miniHalo" cx="42" cy="190" r="10" fill="rgba(255,255,255,.10)"/>
        <circle id="miniDot" cx="42" cy="190" r="5.5" fill="rgba(255,255,255,.92)" stroke="rgba(255,255,255,.22)"/>
      </g>
    </svg>
    <div class="miniMapHint">タップで詳細</div>
  </div>

  <div class="wrap" id="wrap">
    <section class="card" id="viewHero">
      <h2 class="h1">診断を開始</h2>
      <p class="lead">
        20問ごとに章が切り替わり、配色が変化します。進捗は“水が溜まるゲージ”と“神秘の巡礼路”で上昇します。
      </p>
      <div class="pillRow">
        <div class="pill">7段階（1〜7）</div>
        <div class="pill">20問ごとに演出</div>
        <div class="pill">値で色が変わる</div>
        <div class="pill">ミニマップ常時表示</div>
      </div>
      <div class="btnRow">
        <button class="btn primary" id="btnStart">開始</button>
        <button class="btn danger" id="btnResetAll">最初からやり直す（保存を消去）</button>
      </div>
    </section>

    <section class="card" id="viewProfile" hidden>
      <h2 class="h1">プロフィール</h2>
      <p class="lead muted small">※保存復元あり。userIdはURL（?userId=...）でも渡せます。お名前はニックネームでも可能です</p>

      <div style="margin-top:12px;">
        <label for="name">お名前（必須）</label>
        <input class="field" id="name" type="text" placeholder="例：太郎" />
        <div class="err" id="errName">お名前を入力してください。</div>

        <div style="height:12px;"></div>

        <label for="gender">性別（必須）</label>
        <select class="field" id="gender">
          <option value="">選択してください</option>
          <option value="male">male（男性）</option>
          <option value="female">female（女性）</option>
          <option value="other">other（その他）</option>
        </select>
        <div class="err" id="errGender">性別を選択してください。</div>

        <div style="height:12px;"></div>

        <label for="birthday">生年月日（必須）</label>
        <input class="field" id="birthday" type="date" />
        <div class="err" id="errBirthday">生年月日を入力してください。</div>

        <div style="height:12px;"></div>

        <label for="userId">userId（任意）</label>
        <input class="field" id="userId" type="text" placeholder="例：Uxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" />

        <div class="btnRow">
          <button class="btn ghost" id="btnBackToHero">戻る</button>
          <button class="btn primary" id="btnToQuestions">回答へ進む</button>
        </div>

        <div class="toast warn" id="profileRestoreNote" style="display:none;">
          保存データを検出しました。プロフィール・回答・進捗を復元しています。
        </div>
      </div>
    </section>

    <section class="card" id="viewQuestions" hidden>
      <div class="qCard">
        <div class="qTop">
          <div class="qMeta">
            <span class="chip chapterBadge" id="chapterChip">CHAPTER 1 / 5</span>
            <span class="chip" id="qIndexChip">Q 1 / 100</span>
            <span class="chip" id="qTagChip">[S+]</span>
          </div>
          <div class="qMeta">
            <span class="chip">完了 <strong id="doneCountText">0</strong></span>
          </div>
        </div>

        <div class="qText" id="qText">Q1. （設問）</div>

        <div class="scaleWrap">
          <div class="scaleHead">
            <span>1 = まったくそう思わない</span>
            <span class="valuePill" id="valuePill">4</span>
            <span>7 = 非常にそう思う</span>
          </div>

          <!-- 7段階固定 -->
          <input id="range" class="range" type="range" min="1" max="7" step="1" value="4" />
          <div class="tickRow" id="tickRow"></div>
        </div>

        <div class="toast" id="qToast" style="display:none;"></div>

        <div class="sep"></div>

        <div class="btnRow">
          <button class="btn ghost" id="btnJumpProfile">プロフィールへ戻る</button>
          <button class="btn danger" id="btnResetFromQuestions">最初からやり直す（保存を消去）</button>
        </div>
      </div>
    </section>

    <section class="card" id="viewWorry" hidden>
      <h2 class="h1">悩み入力</h2>
      <p class="lead">最終送信payloadの <code>worryText</code> に入ります（最大2000文字）。</p>
      <label for="worryText" style="margin-top:12px;">悩み</label>
      <textarea class="field" id="worryText" maxlength="2000" style="min-height:160px; resize:vertical; line-height:1.6;"></textarea>

      <div class="btnRow" style="justify-content:space-between;">
        <div class="muted small" id="worryCount">0 / 2000</div>
        <button class="btn primary" id="btnShowResult">結果を見る</button>
      </div>
    </section>

    <section class="card" id="viewResult" hidden>
      <h2 class="h1">結果</h2>
      <div class="sep"></div>

      <div class="toast" id="resultToast" style="display:none;"></div>

      <div class="btnRow">
        <button class="btn primary" id="btnFinalSubmit">最終送信（final_submit）</button>
        <button class="btn ghost" id="btnCopyJson">JSONをコピー</button>
        <button class="btn ghost" id="btnDownloadJson">JSONをダウンロード</button>
        <button class="btn danger" id="btnResetFromResult">最初からやり直す（保存を消去）</button>
      </div>

      <div id="jsonPreviewWrap" style="display:none;">
        <div class="sep"></div>
        <p class="lead"><b>JSONプレビュー（WEBHOOK_URL未設定時）</b></p>
        <pre class="field" id="jsonPreview" style="max-height:320px; overflow:auto; white-space:pre; font-size:11.5px; line-height:1.55;"></pre>
      </div>
    </section>

    <div class="footer">© FortuneAI</div>
  </div>

  <div class="bottomNav" id="bottomNav" style="display:none;">
    <div class="bottomNavInner">
      <button class="btn ghost" id="btnPrevQ">前へ</button>
      <button class="btn primary" id="btnNextQ">次へ</button>
    </div>
  </div>

  <!-- 章クリアモーダル -->
  <div class="modalBack" id="chapterModal" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalGlow" aria-hidden="true"></div>
      <h3 class="modalTitle" id="chapterModalTitle">CHAPTER CLEAR</h3>
      <div class="modalBody" id="chapterModalBody"></div>

      <div class="rewardRow">
        <div class="reward" id="reward1"></div>
        <div class="reward" id="reward2"></div>
      </div>

      <div class="btnRow" style="justify-content:flex-end;">
        <button class="btn primary" id="btnChapterContinue">次の章へ</button>
      </div>
    </div>
  </div>

  <!-- 巡礼路（詳細）モーダル -->
  <div class="modalBack" id="mapModal" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalGlow" aria-hidden="true"></div>
      <h3 class="modalTitle">神秘の巡礼路（詳細）</h3>
      <div class="modalBody" id="ascentModalBody">回答が進むほど、光の道が伸び、精霊が上昇します。20問ごとに建造物が点灯します。</div>

      <div class="ascentWrap">
        <svg id="ascentSvg" viewBox="0 0 320 220" width="100%" height="260" aria-label="巡礼路">
          <defs>
            <radialGradient id="ascentGlow" cx="50%" cy="40%" r="70%">
              <stop offset="0%" stop-color="rgba(255,255,255,.12)"/>
              <stop offset="60%" stop-color="rgba(255,255,255,.03)"/>
              <stop offset="100%" stop-color="rgba(255,255,255,0)"/>
            </radialGradient>

            <linearGradient id="ascentStroke" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="var(--accent1)"/>
              <stop offset="55%" stop-color="var(--accent3)"/>
              <stop offset="100%" stop-color="var(--accent2)"/>
            </linearGradient>

            <filter id="softGlow">
              <feGaussianBlur stdDeviation="2.2" result="b"/>
              <feMerge>
                <feMergeNode in="b"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>

          <rect x="0" y="0" width="320" height="220" fill="url(#ascentGlow)"/>

          <g opacity=".95">
            <path d="M160 18 L176 58 L160 48 L144 58 Z" fill="rgba(255,255,255,.10)" stroke="rgba(255,255,255,.16)"/>
            <circle cx="160" cy="18" r="6" fill="rgba(255,255,255,.22)" stroke="rgba(255,255,255,.22)"/>
            <text x="160" y="14" text-anchor="middle" font-size="10" fill="rgba(234,240,255,.85)" style="letter-spacing:.12em;">GOAL</text>
          </g>

          <path id="ascentPathBase"
            d="M42 190
               C 72 176, 88 172, 106 160
               C 126 146, 120 128, 140 118
               C 158 109, 166 128, 184 112
               C 202 96, 180 78, 200 68
               C 224 56, 236 84, 258 58
               C 274 38, 230 32, 196 40
               C 172 46, 168 34, 160 24"
            fill="none"
            stroke="rgba(255,255,255,.14)"
            stroke-width="6"
            stroke-linecap="round"
            stroke-linejoin="round"/>

          <path id="ascentPathProg"
            d="M42 190
               C 72 176, 88 172, 106 160
               C 126 146, 120 128, 140 118
               C 158 109, 166 128, 184 112
               C 202 96, 180 78, 200 68
               C 224 56, 236 84, 258 58
               C 274 38, 230 32, 196 40
               C 172 46, 168 34, 160 24"
            fill="none"
            stroke="url(#ascentStroke)"
            stroke-width="6"
            stroke-linecap="round"
            stroke-linejoin="round"
            filter="url(#softGlow)"/>

          <g id="ascentRunes" opacity=".95"></g>
          <g id="ascentBuildings" opacity=".98"></g>

          <!-- 精霊（位置） -->
          <g id="ascentMarker" filter="url(#softGlow)">
            <circle id="ascentHalo" cx="42" cy="190" r="10" fill="rgba(255,255,255,.10)"/>
            <circle id="ascentDot" cx="42" cy="190" r="5.5" fill="rgba(255,255,255,.92)" stroke="rgba(255,255,255,.22)"/>
            <path id="ascentWisp" class="floaty" d="M42 178 C 46 172, 54 176, 50 184 C 48 188, 44 190, 42 194 C 40 190, 36 188, 34 184 C 30 176, 38 172, 42 178 Z"
              fill="rgba(255,255,255,.18)" stroke="rgba(255,255,255,.22)"/>
          </g>

          <g id="ascentParticles" opacity=".9"></g>

          <text x="42" y="206" text-anchor="start" font-size="10" fill="rgba(234,240,255,.70)" style="letter-spacing:.12em;">START</text>
        </svg>

        <div class="ascentCaption" id="ascentCaption">まずは1問。光が道を描き始めます。</div>
      </div>

      <div class="btnRow" style="justify-content:flex-end;">
        <button class="btn primary" id="btnCloseMap">閉じる</button>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * ここだけ編集（MakeのWebhook）
     ***********************/
    const WEBHOOK_URL = "https://hook.eu2.make.com/7ac62r32ffup0cl0d1kr9h3dpbf8dz3h";
    const STORAGE_KEY = "fortuneai_17type_mystic_ascent_singlefile";

    const AXIS_MAX = 75;

    const THEMES = [
      { name:"CHAPTER 1 / 5", a1:"#7c4dff", a2:"#cfa76e", a3:"#43d3ff", bg0:"#070b1a", bg1:"#0b1231" },
      { name:"CHAPTER 2 / 5", a1:"#43d3ff", a2:"#7c4dff", a3:"#cfa76e", bg0:"#06101a", bg1:"#071a2b" },
      { name:"CHAPTER 3 / 5", a1:"#cfa76e", a2:"#43d3ff", a3:"#7c4dff", bg0:"#120c0a", bg1:"#0b1231" },
      { name:"CHAPTER 4 / 5", a1:"#ff6bd6", a2:"#43d3ff", a3:"#cfa76e", bg0:"#0d0616", bg1:"#08163a" },
      { name:"CHAPTER 5 / 5", a1:"#41d18a", a2:"#cfa76e", a3:"#7c4dff", bg0:"#060f0d", bg1:"#081a2b" },
    ];

    const TYPE_TITLES = {
      "INTJ":"FortuneAI：黒曜アーキテクト（戦略設計者）",
      "INTP":"FortuneAI：蒼天アナリスト（原理解剖者）",
      "ENTJ":"FortuneAI：紅蓮コマンダー（成果指揮者）",
      "ENTP":"FortuneAI：雷光インベンター（変革発明者）",
      "INFJ":"FortuneAI：星導シーア（未来洞察者）",
      "INFP":"FortuneAI：月影バード（理想詩人）",
      "ENFJ":"FortuneAI：旭日メンター（覚醒導師）",
      "ENFP":"FortuneAI：虹彩オラクル（可能性点火者）",
      "ISTJ":"FortuneAI：鉄律マーシャル（秩序監督者）",
      "ISFJ":"FortuneAI：守灯スチュワード（献身支援者）",
      "ESTJ":"FortuneAI：白鋼マーシャル（現場統制者）",
      "ESFJ":"祝祭ホスト（調和演出者）",
      "ISTP":"影刃スミス（実務解体者）",
      "ISFP":"花晶アーティザン（美感匠）",
      "ESTP":"疾風ストライカー（機会攻略者）",
      "ESFP":"陽光パフォーマー（感情起動者）",
      "BAL":"均衡アルケミスト（統合適応者）"
    };

    const TAROT_MAJOR = {
      "INTJ":"隠者","INTP":"正義","ENTJ":"皇帝","ENTP":"魔術師","INFJ":"女教皇","INFP":"星","ENFJ":"太陽","ENFP":"愚者",
      "ISTJ":"教皇","ISFJ":"節制","ESTJ":"戦車","ESFJ":"女帝","ISTP":"力","ISFP":"恋人","ESTP":"運命の輪","ESFP":"世界","BAL":"審判"
    };

    /***********************
     * 設問100（固定）
     ***********************/
    const QUESTIONS = buildDefaultQuestions();
    function buildDefaultQuestions(){
      const out = [];
      const mk = (id, text, tag) => ({ id, text, tag });
      const E = [
        ["初対面の場でも、自然に話しかけるほうだ","[E+]"],
        ["一人で過ごす時間が長いほど安心する","[E-]"],
        ["人が集まる場に行くとエネルギーが湧く","[E+]"],
        ["雑談よりも、必要な会話だけで十分だ","[E-]"],
        ["相談されると、すぐ反応して場を動かしたくなる","[E+]"],
        ["予定が詰まると, まず距離を取りたくなる","[E-]"],
        ["新しいコミュニティに入るのが楽しみだ","[E+]"],
        ["考えをまとめてからでないと発言しにくい","[E-]"],
        ["人前で話すことに抵抗が少ない","[E+]"],
        ["大勢の中にいるより、少人数が落ち着く","[E-]"],
        ["即興で会話を広げるのが得意だ","[E+]"],
        ["会話の後は、一人で回復する時間が必要だ","[E-]"],
        ["周囲のテンションに合わせて盛り上げられる","[E+]"],
        ["発言前に、頭の中で何度もシミュレーションする","[E-]"],
        ["場の空気を読んで率先して動く","[E+]"],
        ["自分の世界に入る時間がないと消耗する","[E-]"],
        ["他人と一緒に作業する方が捗る","[E+]"],
        ["連絡は最低限でいいと感じる","[E-]"],
        ["新しい人脈作りに前向きだ","[E+]"],
        ["静かな環境の方が集中できる","[E-]"],
        ["反応が返ってくるやり取りが好きだ","[E+]"],
        ["自分の内側で結論が出るまで話したくない","[E-]"],
        ["イベントや集まりを企画するのが好きだ","[E+]"],
        ["社交の後は疲れがどっと出る","[E-]"],
        ["人と話すほどアイデアが出る","[E+]"],
      ];
      const S = [
        ["事実や実例をもとに判断することが多い","[S+]"],
        ["抽象的な可能性を考えるのが好きだ","[S-]"],
        ["今ある情報を丁寧に確認して進めたい","[S+]"],
        ["『もし〜なら』の仮説を立てるのが楽しい","[S-]"],
        ["手順や具体策を固めると安心する","[S+]"],
        ["細部より全体像や意味を先に掴みたい","[S-]"],
        ["現実的な制約を踏まえて決める","[S+]"],
        ["直感的なひらめきで方向性を決めることがある","[S-]"],
        ["経験に基づく再現性を重視する","[S+]"],
        ["未来のトレンドや流れを想像しやすい","[S-]"],
        ["数字や根拠があると納得しやすい","[S+]"],
        ["曖昧でもビジョンがあれば動ける","[S-]"],
        ["具体的な改善点を列挙できる","[S+]"],
        ["象徴や比喩で理解する方がしっくりくる","[S-]"],
        ["現場感覚や実務の感触を大切にする","[S+]"],
        ["今は無い可能性にワクワクする","[S-]"],
        ["計画は現実に落とし込めるかを確認する","[S+]"],
        ["常識を疑って新しい解釈を探す","[S-]"],
        ["目の前の課題を一つずつ解くのが得意","[S+]"],
        ["パターンや共通点を見つけるのが得意","[S-]"],
        ["具体例があると理解が早い","[S+]"],
        ["コンセプトや世界観から発想する","[S-]"],
        ["小さな変化に気づきやすい","[S+]"],
        ["本質を掴めば細部は後からでいい","[S-]"],
        ["現実のリスクを先に洗い出す","[S+]"],
      ];
      const T = [
        ["結論は論理の整合性を優先したい","[T+]"],
        ["相手の気持ちを優先して言い方を選ぶ","[T-]"],
        ["公平なルールに沿って判断したい","[T+]"],
        ["衝突を避けるために配慮することが多い","[T-]"],
        ["感情よりも事実を先に整理する","[T+]"],
        ["場の雰囲気や人間関係を重視する","[T-]"],
        ["効率や成果を基準に意思決定する","[T+]"],
        ["相手が傷つかないことが最重要だ","[T-]"],
        ["議論で弱点を指摘されても冷静でいられる","[T+]"],
        ["共感されると安心する","[T-]"],
        ["原因と結果を分解して考える","[T+]"],
        ["誰かの努力や背景を汲み取りたい","[T-]"],
        ["正しい/間違いをはっきりさせたい","[T+]"],
        ["『正しさ』より『やさしさ』を優先する","[T-]"],
        ["合理性が低い提案は見直したくなる","[T+]"],
        ["相手の立場に立つと決めきれないことがある","[T-]"],
        ["数字で説明できると安心する","[T+]"],
        ["感情の納得感がないと進めにくい","[T-]"],
        ["評価基準を明確にしてから動く","[T+]"],
        ["和を乱さないように調整するのが得意","[T-]"],
        ["長期的に得かどうかで選ぶ","[T+]"],
        ["関係性が壊れそうなら方針を変える","[T-]"],
        ["最適解を探すのが好きだ","[T+]"],
        ["相手が安心できる説明を心がける","[T-]"],
        ["結論を急がず気持ちを整える時間も必要","[T-]"],
      ];
      const J = [
        ["締切や計画がある方が動きやすい","[J+]"],
        ["選択肢を残しておきたい","[J-]"],
        ["ToDoを整理して順番に処理する","[J+]"],
        ["その場の流れで柔軟に決めたい","[J-]"],
        ["予定は早めに確定したい","[J+]"],
        ["直前まで迷って最良を選びたい","[J-]"],
        ["ルールや手順に沿って進めたい","[J+]"],
        ["型にハマらず試行錯誤したい","[J-]"],
        ["部屋やデータは整っている方が落ち着く","[J+]"],
        ["散らかっていても必要ならすぐ動ける","[J-]"],
        ["決めたら最後までやり切りたい","[J+]"],
        ["状況次第で方針を変えるのが自然だ","[J-]"],
        ["まずゴールと期限を決める","[J+]"],
        ["やりながら目的が変わることもある","[J-]"],
        ["手帳やメモで管理する習慣がある","[J+]"],
        ["計画よりも勢いが大事だと思う","[J-]"],
        ["『完了』の状態を作るのが好きだ","[J+]"],
        ["未完成でも進めながら整えたい","[J-]"],
        ["予想外が起きてもリカバリ計画を立てる","[J+]"],
        ["選択肢が多いほどワクワクする","[J-]"],
        ["チェックリストがあると安心する","[J+]"],
        ["締切がないと面白い方へ寄り道する","[J-]"],
        ["先に段取りを決めてから動く","[J+]"],
        ["その時の気分で優先順位が変わる","[J-]"],
        ["結論を早めに固めてスッキリしたい","[J+]"],
      ];
      let id = 1;
      for (const [t, tag] of E) out.push(mk(id++, `Q${id-1}. ${t}`, tag));
      for (const [t, tag] of S) out.push(mk(id++, `Q${id-1}. ${t}`, tag));
      for (const [t, tag] of T) out.push(mk(id++, `Q${id-1}. ${t}`, tag));
      for (const [t, tag] of J) out.push(mk(id++, `Q${id-1}. ${t}`, tag));
      if (out.length !== 100) throw new Error("QUESTIONS must be 100");
      return out;
    }

    const $ = (id)=>document.getElementById(id);

    const dom = {
      chapterFlash:$("chapterFlash"),

      viewHero:$("viewHero"),
      viewProfile:$("viewProfile"),
      viewQuestions:$("viewQuestions"),
      viewWorry:$("viewWorry"),
      viewResult:$("viewResult"),

      btnStart:$("btnStart"),
      btnResetAll:$("btnResetAll"),

      btnBackToHero:$("btnBackToHero"),
      btnToQuestions:$("btnToQuestions"),

      name:$("name"),
      gender:$("gender"),
      birthday:$("birthday"),
      userId:$("userId"),
      errName:$("errName"),
      errGender:$("errGender"),
      errBirthday:$("errBirthday"),
      profileRestoreNote:$("profileRestoreNote"),

      qText:$("qText"),
      qTagChip:$("qTagChip"),
      qIndexChip:$("qIndexChip"),
      chapterChip:$("chapterChip"),
      doneCountText:$("doneCountText"),
      valuePill:$("valuePill"),
      range:$("range"),
      tickRow:$("tickRow"),
      qToast:$("qToast"),

      btnPrevQ:$("btnPrevQ"),
      btnNextQ:$("btnNextQ"),
      btnJumpProfile:$("btnJumpProfile"),
      btnResetFromQuestions:$("btnResetFromQuestions"),

      bottomNav:$("bottomNav"),

      worryText:$("worryText"),
      worryCount:$("worryCount"),
      btnShowResult:$("btnShowResult"),

      btnFinalSubmit:$("btnFinalSubmit"),
      btnCopyJson:$("btnCopyJson"),
      btnDownloadJson:$("btnDownloadJson"),
      btnResetFromResult:$("btnResetFromResult"),
      resultToast:$("resultToast"),
      jsonPreviewWrap:$("jsonPreviewWrap"),
      jsonPreview:$("jsonPreview"),

      waterFill:$("waterFill"),
      meterText:$("meterText"),
      topSubtitle:$("topSubtitle"),

      chapterModal:$("chapterModal"),
      chapterModalTitle:$("chapterModalTitle"),
      chapterModalBody:$("chapterModalBody"),
      btnChapterContinue:$("btnChapterContinue"),
      reward1:$("reward1"),
      reward2:$("reward2"),

      mapModal:$("mapModal"),
      btnCloseMap:$("btnCloseMap"),

      miniMapBtn:$("miniMapBtn"),
      miniPct:$("miniPct"),
      miniPathProg:$("miniPathProg"),
      miniHalo:$("miniHalo"),
      miniDot:$("miniDot"),

      ascentCaption:$("ascentCaption"),
      ascentPathProg:$("ascentPathProg"),
      ascentRunes:$("ascentRunes"),
      ascentBuildings:$("ascentBuildings"),
      ascentHalo:$("ascentHalo"),
      ascentDot:$("ascentDot"),
      ascentWisp:$("ascentWisp"),
      ascentParticles:$("ascentParticles"),
      ascentSvg:$("ascentSvg"),

      topbar:$("topbar"),
      wrap:$("wrap"),
    };

    const state = {
      view:"hero",
      currentIndex:0,
      profile:{ name:"", gender:"", birthday:"" },
      userId:"",
      answers:new Array(100).fill(4),
      done:new Array(100).fill(false),
      worryText:"",
      lastPayload:null,
      lastChapterShown:0
    };

    document.addEventListener("gesturestart", (e)=>e.preventDefault(), { passive:false });
    document.addEventListener("gesturechange",(e)=>e.preventDefault(), { passive:false });
    document.addEventListener("gestureend",  (e)=>e.preventDefault(), { passive:false });

    const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));

    function parseQuery(){
      const q = new URLSearchParams(location.search);
      return { userId: q.get("userId") || "" };
    }

    function save(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        view:state.view,
        currentIndex:state.currentIndex,
        profile:state.profile,
        userId:state.userId,
        answers:state.answers,
        done:state.done,
        worryText:state.worryText,
        lastChapterShown:state.lastChapterShown
      }));
    }

    function load(){
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      try{
        const data = JSON.parse(raw);
        if (!data || typeof data !== "object") return false;
        if (!Array.isArray(data.answers) || data.answers.length !== 100) return false;

        state.view = data.view || "hero";
        state.currentIndex = clamp(Number(data.currentIndex || 0), 0, 99);

        state.profile = {
          name: String(data.profile?.name || ""),
          gender: String(data.profile?.gender || ""),
          birthday: String(data.profile?.birthday || ""),
        };
        state.userId = String(data.userId || "");

        state.answers = data.answers.map(v => clamp(Number(v ?? 4), 1, 7));

        if (Array.isArray(data.done) && data.done.length === 100){
          state.done = data.done.map(Boolean);
        } else {
          state.done = new Array(100).fill(false);
          for (let i=0;i<state.currentIndex;i++) state.done[i] = true;
        }

        state.worryText = String(data.worryText || "");
        state.lastChapterShown = Number(data.lastChapterShown || 0);
        return true;
      }catch{
        return false;
      }
    }

    function clearAll(){
      localStorage.removeItem(STORAGE_KEY);
      state.view="hero";
      state.currentIndex=0;
      state.profile={name:"",gender:"",birthday:""};
      state.userId="";
      state.answers=new Array(100).fill(4);
      state.done=new Array(100).fill(false);
      state.worryText="";
      state.lastPayload=null;
      state.lastChapterShown=0;
      renderAll();
    }

    function setView(v){
      state.view=v;
      save();
      renderAll();
      window.scrollTo({top:0, behavior:"smooth"});
    }

    function answeredDoneCount(){
      return state.done.reduce((a,b)=>a+(b?1:0),0);
    }

    function currentChapterByDone(doneCount){
      return clamp(Math.floor(doneCount/20), 0, 4);
    }

    function applyThemeByDone(doneCount){
      const th = THEMES[currentChapterByDone(doneCount)];
      document.documentElement.style.setProperty("--accent1", th.a1);
      document.documentElement.style.setProperty("--accent2", th.a2);
      document.documentElement.style.setProperty("--accent3", th.a3);
      document.documentElement.style.setProperty("--bg0", th.bg0);
      document.documentElement.style.setProperty("--bg1", th.bg1);
      dom.chapterChip.textContent = th.name;
      dom.topSubtitle.textContent = `章：${th.name}｜巡礼路で上昇（7段階）`;
    }

    function updateMeter(){
      const done = answeredDoneCount();
      const pct = (done/100)*100;
      dom.waterFill.style.width = pct.toFixed(1) + "%";
      dom.meterText.textContent = `${done} / 100`;
      dom.waterFill.parentElement.setAttribute("aria-valuenow", String(done));
      applyThemeByDone(done);
      updateAscent(done);
      updateMini(done);
    }

    function valueColor(v){
      const map = {
        1: "color-mix(in oklab, var(--accent1) 70%, black 25%)",
        2: "color-mix(in oklab, var(--accent1) 70%, var(--accent3) 20%)",
        3: "color-mix(in oklab, var(--accent3) 70%, var(--accent1) 20%)",
        4: "color-mix(in oklab, var(--accent3) 55%, rgba(255,255,255,.10) 0%)",
        5: "color-mix(in oklab, var(--accent2) 55%, var(--accent3) 30%)",
        6: "color-mix(in oklab, var(--accent2) 72%, var(--accent3) 12%)",
        7: "color-mix(in oklab, var(--accent2) 85%, white 8%)",
      };
      return map[clamp(v,1,7)];
    }

    function applyThumbScale(v){
      const dist = Math.abs(v-4);
      const t = dist/3;
      dom.range.style.setProperty("--thumbScale", String(1 + t*0.45));
    }

    function applyRangePaint(v){
      const pct = ((v-1)/6)*100;
      dom.range.style.setProperty("--fillPct", pct.toFixed(2) + "%");
      dom.range.style.setProperty("--fillColor", valueColor(v));
      dom.valuePill.textContent = String(v);
      applyThumbScale(v);

      dom.tickRow.querySelectorAll("button[data-v]").forEach(b=>{
        b.classList.toggle("on", Number(b.dataset.v) === v);
      });
    }

    function renderTicks(current){
      dom.tickRow.innerHTML = "";
      for (let v=1; v<=7; v++){
        const b = document.createElement("button");
        b.type="button";
        b.className = "tickBtn" + (v===current ? " on" : "");
        b.textContent = String(v);
        b.dataset.v = String(v);
        b.addEventListener("click", ()=> setAnswerValue(v, true));
        dom.tickRow.appendChild(b);
      }
    }

    function setAnswerValue(v, markDone){
      const i = state.currentIndex;
      const val = clamp(Number(v),1,7);
      state.answers[i] = val;
      if (markDone) state.done[i] = true;
      save();
      dom.range.value = String(val);
      applyRangePaint(val);
      dom.doneCountText.textContent = String(answeredDoneCount());
      updateMeter();
    }

    function validateProfile(){
      let ok = true;
      dom.errName.style.display="none";
      dom.errGender.style.display="none";
      dom.errBirthday.style.display="none";
      if (!dom.name.value.trim()){ dom.errName.style.display="block"; ok=false; }
      if (!dom.gender.value){ dom.errGender.style.display="block"; ok=false; }
      if (!dom.birthday.value){ dom.errBirthday.style.display="block"; ok=false; }
      return ok;
    }

    function syncProfileFromInputs(){
      state.profile.name = dom.name.value.trim();
      state.profile.gender = dom.gender.value;
      state.profile.birthday = dom.birthday.value;
      state.userId = dom.userId.value.trim();
      save();
    }

    function answerToValue(ans){ return (Number(ans) - 4); }

    function applyTagToAxis(tag, val, scores){
      const m = String(tag).match(/\[([ESTJ])([+-])\]/);
      if (!m) return;
      const axis = m[1];
      const sign = m[2];
      const v = (sign === "+") ? val : -val;
      if (axis==="E") scores.E += v;
      if (axis==="S") scores.S += v;
      if (axis==="T") scores.T += v;
      if (axis==="J") scores.J += v;
    }

    function computeScores(){
      const scores = {E:0,S:0,T:0,J:0};
      for (let i=0;i<100;i++){
        const val = answerToValue(state.answers[i]);
        applyTagToAxis(QUESTIONS[i].tag, val, scores);
      }
      scores.E = clamp(scores.E, -AXIS_MAX, AXIS_MAX);
      scores.S = clamp(scores.S, -AXIS_MAX, AXIS_MAX);
      scores.T = clamp(scores.T, -AXIS_MAX, AXIS_MAX);
      scores.J = clamp(scores.J, -AXIS_MAX, AXIS_MAX);
      return scores;
    }

    function computeType(scores){
      const absE = Math.abs(scores.E), absS=Math.abs(scores.S), absT=Math.abs(scores.T), absJ=Math.abs(scores.J);
      const isBAL = (absE < 8 && absS < 8 && absT < 8 && absJ < 8);
      if (isBAL) return { typeCode:"BAL", isBAL:true };
      const EorI = (scores.E >= 0) ? "E" : "I";
      const SorN = (scores.S >= 0) ? "S" : "N";
      const TorF = (scores.T >= 0) ? "T" : "F";
      const JorP = (scores.J >= 0) ? "J" : "P";
      return { typeCode: (EorI+SorN+TorF+JorP), isBAL:false };
    }

    function buildPayload(){
      const payload = {
        action:"final_submit",
        userId: (state.userId || "").trim(),
        step:999,
        profile:{
          gender: state.profile.gender,
          name: state.profile.name,
          birthday: state.profile.birthday
        },
        answers: state.answers.map(v => Number(v)),
        worryText: state.worryText || ""
      };
      if (!payload.profile.name || !payload.profile.gender || !payload.profile.birthday) throw new Error("profile incomplete");
      if (!Array.isArray(payload.answers) || payload.answers.length !== 100) throw new Error("answers invalid");
      for (const a of payload.answers){
        if (!Number.isInteger(a) || a<1 || a>7) throw new Error("answers must be 1..7 integers");
      }
      if (payload.worryText.length > 2000) payload.worryText = payload.worryText.slice(0,2000);
      return payload;
    }

    function safeJson(obj){ return JSON.stringify(obj, null, 2); }

    async function copyToClipboard(text){
      try{ await navigator.clipboard.writeText(text); return true; }
      catch{
        const ta = document.createElement("textarea");
        ta.value=text; ta.style.position="fixed"; ta.style.left="-9999px";
        document.body.appendChild(ta); ta.focus(); ta.select();
        let ok=false; try{ ok=document.execCommand("copy"); }catch{ ok=false; }
        ta.remove(); return ok;
      }
    }

    function downloadText(filename, text){
      const blob = new Blob([text], {type:"application/json;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href=url; a.download=filename;
      document.body.appendChild(a);
      a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    async function finalSubmit(){
      dom.resultToast.style.display="none";
      let payload;
      try{ payload = buildPayload(); }
      catch(e){
        dom.resultToast.className="toast bad";
        dom.resultToast.textContent="送信前チェックに失敗しました： " + (e?.message || e);
        dom.resultToast.style.display="block";
        return;
      }
      state.lastPayload = payload;
      save();

      const jsonText = safeJson(payload);

      if (!WEBHOOK_URL){
        dom.jsonPreviewWrap.style.display="block";
        dom.jsonPreview.textContent = jsonText;
        dom.resultToast.className="toast warn";
        dom.resultToast.textContent="WEBHOOK_URL未設定のため送信せず、JSONを表示しました。";
        dom.resultToast.style.display="block";
        return;
      }

      dom.resultToast.className="toast";
      dom.resultToast.textContent="送信中…";
      dom.resultToast.style.display="block";

      try{
        const res = await fetch(WEBHOOK_URL, {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: jsonText
        });
        if (!res.ok){
          const body = await res.text().catch(()=> "");
          dom.resultToast.className="toast bad";
          dom.resultToast.textContent=`送信失敗：HTTP ${res.status}\n${body ? body.slice(0,400) : ""}`;
          return;
        }
        const body = await res.text().catch(()=> "");
        dom.resultToast.className="toast ok";
        dom.resultToast.textContent=`送信成功：HTTP ${res.status}\n${body ? body.slice(0,400) : ""}`;
      }catch(e){
        dom.resultToast.className="toast bad";
        dom.resultToast.textContent="送信エラー： " + (e?.message || e);
      }
    }

    /***********************
     * 巡礼路（進捗で上昇）＋建物（20問ごと）
     ***********************/
    const ascent = { pathLen:0, lastDone:0, raf:0, particles:[] };
    const mini = { pathLen:0 };

    function initAscent(){
      ascent.pathLen = dom.ascentPathProg.getTotalLength();
      dom.ascentPathProg.style.strokeDasharray = `${ascent.pathLen} ${ascent.pathLen}`;
      dom.ascentPathProg.style.strokeDashoffset = `${ascent.pathLen}`;

      mini.pathLen = dom.miniPathProg.getTotalLength();
      dom.miniPathProg.style.strokeDasharray = `${mini.pathLen} ${mini.pathLen}`;
      dom.miniPathProg.style.strokeDashoffset = `${mini.pathLen}`;

      renderAscentRunes();
      renderAscentBuildings();
      seedAscentParticles(22);
      cancelAnimationFrame(ascent.raf);
      ascent.raf = requestAnimationFrame(ascentAnimate);
    }

    function renderAscentRunes(){
      dom.ascentRunes.innerHTML = "";
      for (let n=5; n<=100; n+=5){
        const t = n/100;
        const pt = dom.ascentPathProg.getPointAtLength(ascent.pathLen*t);

        const g = document.createElementNS("http://www.w3.org/2000/svg","g");
        g.setAttribute("data-node", String(n));
        const is20 = (n%20===0), is10=(n%10===0);

        if (is20){
          const ring = document.createElementNS("http://www.w3.org/2000/svg","circle");
          ring.setAttribute("cx", pt.x); ring.setAttribute("cy", pt.y);
          ring.setAttribute("r", 10);
          ring.setAttribute("fill","rgba(255,255,255,.06)");
          ring.setAttribute("stroke","rgba(255,255,255,.20)");
          ring.setAttribute("stroke-width","1.2");
          g.appendChild(ring);
        } else if (is10){
          const diamond = document.createElementNS("http://www.w3.org/2000/svg","path");
          diamond.setAttribute("d", `M ${pt.x} ${pt.y-6} L ${pt.x+6} ${pt.y} L ${pt.x} ${pt.y+6} L ${pt.x-6} ${pt.y} Z`);
          diamond.setAttribute("fill","rgba(255,255,255,.06)");
          diamond.setAttribute("stroke","rgba(255,255,255,.16)");
          g.appendChild(diamond);
        } else {
          const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
          dot.setAttribute("cx", pt.x); dot.setAttribute("cy", pt.y);
          dot.setAttribute("r", 3.6);
          dot.setAttribute("fill","rgba(255,255,255,.06)");
          dot.setAttribute("stroke","rgba(255,255,255,.14)");
          g.appendChild(dot);
        }

        dom.ascentRunes.appendChild(g);
      }
    }

    function renderAscentBuildings(){
      dom.ascentBuildings.innerHTML = "";
      const milestones = [20,40,60,80,100];
      milestones.forEach(m=>{
        const t = m/100;
        const pt = dom.ascentPathProg.getPointAtLength(ascent.pathLen*t);

        const g = document.createElementNS("http://www.w3.org/2000/svg","g");
        g.setAttribute("data-b", String(m));
        g.setAttribute("class","floaty");

        const idx = Math.min(4, Math.floor((m-1)/20));
        const color = ["rgba(255,255,255,.16)","rgba(255,255,255,.14)","rgba(255,255,255,.16)","rgba(255,255,255,.14)","rgba(255,255,255,.18)"][idx];

        const base = document.createElementNS("http://www.w3.org/2000/svg","path");
        base.setAttribute("d", `M ${pt.x-8} ${pt.y+10} L ${pt.x+8} ${pt.y+10} L ${pt.x+6} ${pt.y+18} L ${pt.x-6} ${pt.y+18} Z`);
        base.setAttribute("fill","rgba(0,0,0,.18)");
        base.setAttribute("stroke", color);
        base.setAttribute("stroke-width","1.1");
        g.appendChild(base);

        const spire = document.createElementNS("http://www.w3.org/2000/svg","path");
        spire.setAttribute("d", `M ${pt.x} ${pt.y-16} L ${pt.x+10} ${pt.y+10} L ${pt.x} ${pt.y+4} L ${pt.x-10} ${pt.y+10} Z`);
        spire.setAttribute("fill","rgba(255,255,255,.06)");
        spire.setAttribute("stroke", color);
        spire.setAttribute("stroke-width","1.1");
        g.appendChild(spire);

        const gem = document.createElementNS("http://www.w3.org/2000/svg","circle");
        gem.setAttribute("cx", pt.x);
        gem.setAttribute("cy", pt.y-16);
        gem.setAttribute("r", 3.8);
        gem.setAttribute("fill", "rgba(255,255,255,.28)");
        gem.setAttribute("stroke", "rgba(255,255,255,.22)");
        g.appendChild(gem);

        dom.ascentBuildings.appendChild(g);
      });
    }

    function seedAscentParticles(k){
      ascent.particles = [];
      for (let i=0;i<k;i++){
        ascent.particles.push({
          x: 40 + Math.random()*240,
          y: 30 + Math.random()*170,
          r: 1.2 + Math.random()*2.1,
          a: 0.22 + Math.random()*0.35,
          ph: Math.random()*Math.PI*2
        });
      }
      drawAscentParticles(0);
    }

    function drawAscentParticles(time){
      dom.ascentParticles.innerHTML = "";
      for (const p of ascent.particles){
        const yy = p.y + Math.sin(time*0.0012 + p.ph) * 6;
        const xx = p.x + Math.cos(time*0.0010 + p.ph) * 6;
        const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
        c.setAttribute("cx", xx.toFixed(2));
        c.setAttribute("cy", yy.toFixed(2));
        c.setAttribute("r", p.r.toFixed(2));
        c.setAttribute("fill", "rgba(255,255,255,.65)");
        c.setAttribute("opacity", p.a.toFixed(2));
        dom.ascentParticles.appendChild(c);
      }
    }

    function ascentAnimate(t){
      drawAscentParticles(t);
      dom.ascentHalo.setAttribute("opacity", String(0.22 + 0.06*Math.sin(t*0.003)));
      ascent.raf = requestAnimationFrame(ascentAnimate);
    }

    function updateAscent(doneCount){
      const pct = doneCount/100;
      const offset = ascent.pathLen * (1 - pct);
      dom.ascentPathProg.style.strokeDashoffset = String(offset);

      const pt = dom.ascentPathProg.getPointAtLength(ascent.pathLen * pct);
      dom.ascentHalo.setAttribute("cx", pt.x);
      dom.ascentHalo.setAttribute("cy", pt.y);
      dom.ascentDot.setAttribute("cx", pt.x);
      dom.ascentDot.setAttribute("cy", pt.y);

      dom.ascentWisp.setAttribute("transform", `translate(${(pt.x-42).toFixed(2)}, ${(pt.y-190).toFixed(2)})`);

      dom.ascentRunes.querySelectorAll("g[data-node]").forEach(g=>{
        const n = Number(g.getAttribute("data-node"));
        const on = (doneCount >= n);
        g.style.opacity = on ? "1" : ".45";
        g.style.filter = on ? "url(#softGlow)" : "none";
      });

      dom.ascentBuildings.querySelectorAll("g[data-b]").forEach(g=>{
        const m = Number(g.getAttribute("data-b"));
        const on = (doneCount >= m);
        g.style.opacity = on ? "1" : ".28";
        g.style.filter = on ? "url(#softGlow)" : "none";
      });

      let cap = "まずは1問。光が道を描き始めます。";
      if (doneCount >= 10) cap = "巡礼路が見えてきました。直感でテンポ良く。";
      if (doneCount >= 20) cap = "第1章突破。建造物が点灯し、色相が切り替わります。";
      if (doneCount >= 50) cap = "半分到達。尖塔の気配が濃くなっています。";
      if (doneCount >= 80) cap = "残りわずか。最後まで一気に。";
      if (doneCount >= 100) cap = "到達。尖塔の頂で結果が統合されます。";
      dom.ascentCaption.textContent = cap;

      if (doneCount > ascent.lastDone){
        dom.ascentDot.classList.remove("ascentPulse");
        void dom.ascentDot.offsetWidth;
        dom.ascentDot.classList.add("ascentPulse");
        ascent.lastDone = doneCount;
        try{ navigator.vibrate?.([18]); }catch{}
      }
    }

    function updateMini(doneCount){
      const pct = doneCount/100;
      const offset = mini.pathLen * (1 - pct);
      dom.miniPathProg.style.strokeDashoffset = String(offset);
      dom.miniPct.textContent = `${Math.round(pct*100)}%`;

      const pt = dom.miniPathProg.getPointAtLength(mini.pathLen * pct);
      dom.miniHalo.setAttribute("cx", pt.x);
      dom.miniHalo.setAttribute("cy", pt.y);
      dom.miniDot.setAttribute("cx", pt.x);
      dom.miniDot.setAttribute("cy", pt.y);
    }

    function flashChapter(){
      dom.chapterFlash.classList.add("on");
      setTimeout(()=> dom.chapterFlash.classList.remove("on"), 420);
    }

    function maybeShowChapterClear(){
      const done = answeredDoneCount();
      const milestones = [20,40,60,80,100];
      const hit = milestones.find(m => done >= m && state.lastChapterShown < m);
      if (!hit) return;

      state.lastChapterShown = hit;
      save();

      flashChapter();

      const chapIdx = Math.min(4, Math.floor((hit-1)/20));
      const nextIdx = Math.min(4, chapIdx+1);

      dom.chapterModalTitle.textContent = `CHAPTER CLEAR（${hit}/100）`;
      dom.chapterModalBody.textContent = (hit === 100)
        ? "最終章を突破しました。結果へ進みましょう。"
        : `章を突破しました。次の章（${THEMES[nextIdx].name}）へ移行します。`;

      dom.reward1.textContent = `報酬：建造物点灯（${hit}到達）`;
      dom.reward2.textContent = (hit === 100)
        ? "ボーナス：結果の統合処理が解放されます。"
        : "ボーナス：色相が切り替わり、集中が続きやすくなります。";

      dom.chapterModal.style.display = "flex";
      dom.chapterModal.setAttribute("aria-hidden","false");
      try{ navigator.vibrate?.([25, 45, 25]); }catch{}
    }

    function closeChapterModal(){
      dom.chapterModal.style.display = "none";
      dom.chapterModal.setAttribute("aria-hidden","true");
      updateMeter();
    }

    function openMapModal(){
      dom.mapModal.style.display = "flex";
      dom.mapModal.setAttribute("aria-hidden","false");
      updateMeter();
    }
    function closeMapModal(){
      dom.mapModal.style.display = "none";
      dom.mapModal.setAttribute("aria-hidden","true");
    }

    function hideAllViews(){
      dom.viewHero.hidden=true;
      dom.viewProfile.hidden=true;
      dom.viewQuestions.hidden=true;
      dom.viewWorry.hidden=true;
      dom.viewResult.hidden=true;
    }

    function renderProfile(){
      dom.name.value = state.profile.name || "";
      dom.gender.value = state.profile.gender || "";
      dom.birthday.value = state.profile.birthday || "";
      dom.userId.value = state.userId || "";
    }

    function renderQuestion(){
      const i = state.currentIndex;
      const q = QUESTIONS[i];
      dom.qText.textContent = q.text;
      dom.qTagChip.textContent = q.tag; // 表示はCSSで非表示
      dom.qIndexChip.textContent = `Q ${i+1} / 100`;

      const done = answeredDoneCount();
      dom.doneCountText.textContent = String(done);

      const current = Number.isInteger(state.answers[i]) ? state.answers[i] : 4;
      dom.range.value = String(current);
      renderTicks(current);
      applyRangePaint(current);

      dom.btnPrevQ.disabled = (i===0);
      dom.btnNextQ.textContent = (i===99) ? "次へ（悩み入力）" : "次へ";
    }

    function updateWorryCount(){
      const len = dom.worryText.value.length;
      dom.worryCount.textContent = `${len} / 2000`;
    }

    function renderWorry(){
      dom.worryText.value = state.worryText || "";
      updateWorryCount();
    }

    function renderResult(){
      dom.resultToast.style.display="none";
      dom.jsonPreviewWrap.style.display="none";

      let payload;
      try{ payload = buildPayload(); state.lastPayload = payload; save(); }
      catch(e){
        dom.resultToast.className="toast bad";
        dom.resultToast.textContent="結果表示前のチェックに失敗しました： " + (e?.message || e);
        dom.resultToast.style.display="block";
        return;
      }

      const scores = computeScores();
      const t = computeType(scores);
      const code = t.typeCode;

      const title = TYPE_TITLES[code] || "（未定義）";
      const tarot = TAROT_MAJOR[code] || "—";

      dom.resultToast.className="toast ok";
      dom.resultToast.textContent = `判定：${code}\n${title}\n（象徴）タロット：${tarot}\n\nこのまま最終送信できます。`;
      dom.resultToast.style.display="block";
    }

    function setBodyMode(){
      const inQuestions = (state.view==="questions");
      document.body.classList.toggle("isQuestions", inQuestions);
      recalcLayoutVars();
    }

    function recalcLayoutVars(){
      // 実測して CSS var 更新（端末差/2段ヘッダー差吸収）
      const headerH = dom.topbar?.offsetHeight || 110;
      const bottomH = (dom.bottomNav?.style.display !== "none") ? (dom.bottomNav?.offsetHeight || 86) : 0;
      document.documentElement.style.setProperty("--headerH", headerH + "px");
      document.documentElement.style.setProperty("--bottomH", bottomH + "px");
    }

    function renderAll(){
      hideAllViews();

      const inQuestions = (state.view==="questions");
      dom.bottomNav.style.display = inQuestions ? "block" : "none";
      dom.miniMapBtn.style.display = inQuestions ? "block" : "none";

      if (state.view==="hero"){ dom.viewHero.hidden=false; }
      if (state.view==="profile"){ dom.viewProfile.hidden=false; renderProfile(); }
      if (state.view==="questions"){ dom.viewQuestions.hidden=false; renderQuestion(); }
      if (state.view==="worry"){ dom.viewWorry.hidden=false; renderWorry(); }
      if (state.view==="result"){ dom.viewResult.hidden=false; renderResult(); }

      setBodyMode();
      updateMeter();

      // 直後にもう一回（レイアウトが反映された後の高さを拾う）
      requestAnimationFrame(recalcLayoutVars);
    }

    dom.btnStart.addEventListener("click", ()=> setView("profile"));
    dom.btnResetAll.addEventListener("click", clearAll);
    dom.btnBackToHero.addEventListener("click", ()=> setView("hero"));

    dom.btnToQuestions.addEventListener("click", ()=>{
      if (!validateProfile()) return;
      syncProfileFromInputs();
      setView("questions");
    });

    dom.name.addEventListener("input", syncProfileFromInputs);
    dom.gender.addEventListener("change", syncProfileFromInputs);
    dom.birthday.addEventListener("change", syncProfileFromInputs);
    dom.userId.addEventListener("input", syncProfileFromInputs);

    dom.btnResetFromQuestions.addEventListener("click", clearAll);
    dom.btnResetFromResult.addEventListener("click", clearAll);

    dom.btnJumpProfile.addEventListener("click", ()=> setView("profile"));

    dom.range.addEventListener("input", ()=>{
      const v = clamp(Number(dom.range.value),1,7);
      setAnswerValue(v, true);
    });

    dom.btnPrevQ.addEventListener("click", ()=>{
      if (state.currentIndex>0){
        state.currentIndex--;
        save();
        renderQuestion();
        updateMeter();
      }
    });

    dom.btnNextQ.addEventListener("click", ()=>{
      const i = state.currentIndex;
      state.done[i] = true;

      if (i === 99){
        save(); updateMeter(); maybeShowChapterClear();
        setView("worry");
        return;
      }
      state.currentIndex++;
      save();
      renderQuestion();
      updateMeter();
      maybeShowChapterClear();
    });

    dom.btnChapterContinue.addEventListener("click", closeChapterModal);
    dom.chapterModal.addEventListener("click", (e)=>{ if (e.target===dom.chapterModal) closeChapterModal(); });

    dom.miniMapBtn.addEventListener("click", openMapModal);
    dom.btnCloseMap.addEventListener("click", closeMapModal);
    dom.mapModal.addEventListener("click", (e)=>{ if (e.target===dom.mapModal) closeMapModal(); });

    dom.worryText.addEventListener("input", ()=>{
      state.worryText = dom.worryText.value.slice(0,2000);
      updateWorryCount();
      save();
    });

    dom.btnShowResult.addEventListener("click", ()=> setView("result"));
    dom.btnFinalSubmit.addEventListener("click", finalSubmit);

    dom.btnCopyJson.addEventListener("click", async ()=>{
      let payload = state.lastPayload;
      if (!payload){
        try{ payload = buildPayload(); state.lastPayload = payload; save(); }
        catch(e){
          dom.resultToast.className="toast bad";
          dom.resultToast.textContent="JSON生成に失敗しました： " + (e?.message || e);
          dom.resultToast.style.display="block";
          return;
        }
      }
      const ok = await copyToClipboard(safeJson(payload));
      dom.resultToast.className = "toast " + (ok ? "ok" : "bad");
      dom.resultToast.textContent = ok ? "JSONをコピーしました。" : "コピーに失敗しました。";
      dom.resultToast.style.display="block";
    });

    dom.btnDownloadJson.addEventListener("click", ()=>{
      let payload = state.lastPayload;
      if (!payload){
        try{ payload = buildPayload(); state.lastPayload = payload; save(); }
        catch(e){
          dom.resultToast.className="toast bad";
          dom.resultToast.textContent="JSON生成に失敗しました： " + (e?.message || e);
          dom.resultToast.style.display="block";
          return;
        }
      }
      downloadText("fortuneai_final_submit.json", safeJson(payload));
      dom.resultToast.className="toast ok";
      dom.resultToast.textContent="JSONをダウンロードしました。";
      dom.resultToast.style.display="block";
    });

    window.addEventListener("resize", ()=>{ recalcLayoutVars(); });

    /***********************
     * Boot
     ***********************/
    (function init(){
      const q = parseQuery();
      if (q.userId) state.userId = q.userId;

      const restored = load();
      if (restored){
        if (q.userId) state.userId = q.userId;
        dom.profileRestoreNote.style.display="block";
        setTimeout(()=> dom.profileRestoreNote.style.display="none", 2500);
      }

      initAscent();
      renderAll();
      recalcLayoutVars();
      requestAnimationFrame(recalcLayoutVars);
    })();
  </script>
</body>
</html>
