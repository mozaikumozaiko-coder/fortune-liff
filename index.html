<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>FortuneAI式 17タイプ診断</title>

  <style>
    :root{
      --bg0:#070b1a;
      --bg1:#0b1231;

      --card: rgba(255,255,255,.06);
      --line: rgba(255,255,255,.14);
      --text:#eaf0ff;

      --accent1:#7c4dff;
      --accent2:#cfa76e;
      --accent3:#43d3ff;

      --shadow: 0 18px 60px rgba(0,0,0,.38);
      --r: 18px;

      --safeBottom: env(safe-area-inset-bottom, 0px);
      --safeTop: env(safe-area-inset-top, 0px);

      --chapterPulse: 0; /* 章クリア演出の強度（0..1） */
    }

    *{box-sizing:border-box}
    html, body{height:100%; overscroll-behavior:none; -webkit-text-size-adjust:100%;}
    body{
      margin:0;
      color:var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Sans", "Yu Gothic", sans-serif;
      background:
        radial-gradient(1200px 650px at 15% 5%, color-mix(in oklab, var(--accent1) 35%, transparent), transparent 62%),
        radial-gradient(900px 540px at 85% 25%, color-mix(in oklab, var(--accent2) 26%, transparent), transparent 62%),
        radial-gradient(900px 540px at 65% 85%, color-mix(in oklab, var(--accent3) 18%, transparent), transparent 62%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
      touch-action: pan-y;
      position:relative;
    }

    /* 章クリア演出：背景だけを強くする（文字は崩さない） */
    body::before{
      content:"";
      position:fixed; inset:0;
      pointer-events:none;
      z-index: 5;
      opacity: calc(var(--chapterPulse) * .85);
      background:
        radial-gradient(900px 520px at 20% 20%, color-mix(in oklab, var(--accent1) 45%, transparent), transparent 62%),
        radial-gradient(900px 520px at 80% 30%, color-mix(in oklab, var(--accent2) 35%, transparent), transparent 65%),
        radial-gradient(900px 520px at 60% 85%, color-mix(in oklab, var(--accent3) 30%, transparent), transparent 68%);
      mix-blend-mode: screen;
      transition: opacity .45s ease;
    }

    .wrap{
      max-width:1180px;
      margin:0 auto;
      padding: 14px 14px calc(90px + var(--safeBottom));
      position:relative;
      z-index:10;
    }

    /* ===== Header (スマホ2段化) ===== */
    .topbar{
      position:sticky; top:0; z-index:90;
      padding-top: var(--safeTop);
      background: linear-gradient(180deg, rgba(7,11,26,.92), rgba(11,18,49,.65));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .topbarInner{
      max-width:1180px;
      margin:0 auto;
      padding: 12px 14px 12px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }

    /* スマホ：縦積み（2段） */
    @media (max-width: 680px){
      .topbarInner{
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }
      .meter{
        width: 100% !important;
        min-width: unset !important;
        justify-content: space-between !important;
      }
      .subtitle{
        max-width: 92vw !important;
      }
    }

    .brand{display:flex; gap:12px; align-items:center; min-width: 220px;}
    .orb{
      width:44px; height:44px; border-radius:999px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.92), rgba(255,255,255,.10) 42%, rgba(124,77,255,.28) 72%, rgba(207,167,110,.18));
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 0 26px color-mix(in oklab, var(--accent1) 28%, transparent),
                  0 0 18px color-mix(in oklab, var(--accent2) 18%, transparent);
      flex: 0 0 auto;
    }
    .title{font-size:14px; letter-spacing:.06em; margin:0; line-height:1.2;}
    .subtitle{
      font-size:12px; opacity:.86; margin-top:4px; line-height:1.35;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:56vw;
    }

    .meter{
      width: min(520px, 52vw);
      min-width: 220px;
      display:flex; align-items:center; gap:10px;
      justify-content:flex-end;
    }
    .meterText{font-size:12px; opacity:.92; min-width:86px; text-align:right; white-space:nowrap;}
    .waterBar{
      position:relative; height:16px; width:100%;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      overflow:hidden;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.08);
    }
    .waterFill{
      position:absolute; inset:0 auto 0 0; width:0%;
      border-radius:999px;
      background:
        linear-gradient(90deg,
          color-mix(in oklab, var(--accent1) 90%, white 10%),
          color-mix(in oklab, var(--accent3) 70%, white 10%),
          color-mix(in oklab, var(--accent2) 85%, white 10%));
      filter:saturate(1.05);
      transition: width .30s ease;
      overflow:hidden;
    }
    .waterFill::before{
      content:"";
      position:absolute; inset:-10px -40px -10px -40px;
      background:
        radial-gradient(18px 10px at 20px 18px, rgba(255,255,255,.34), rgba(255,255,255,0) 70%),
        radial-gradient(22px 12px at 60px 26px, rgba(255,255,255,.22), rgba(255,255,255,0) 72%),
        radial-gradient(18px 10px at 100px 18px, rgba(255,255,255,.30), rgba(255,255,255,0) 70%);
      opacity:.55;
      animation: waveMove 2.4s linear infinite;
      mix-blend-mode: screen;
    }
    @keyframes waveMove{0%{transform:translateX(0)}100%{transform:translateX(80px)}}

    .card{
      margin-top:14px;
      border:1px solid var(--line);
      background: var(--card);
      border-radius: var(--r);
      padding: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
    }
    .h1{font-size:18px; margin:0 0 8px; letter-spacing:.05em; line-height:1.25;}
    .lead{margin:0; font-size:13px; opacity:.88; line-height:1.75;}
    .muted{opacity:.84}
    .small{font-size:12px}
    .sep{height:1px; background: rgba(255,255,255,.10); margin: 12px 0;}
    .miniLine{height:1px; background: rgba(255,255,255,.10); margin: 10px 0;}

    .grid2{display:grid; grid-template-columns:1fr; gap:14px; align-items:start;}
    @media(min-width:980px){ .grid2{grid-template-columns:1.35fr .65fr;} }
    .sideStack{display:grid; gap:14px;}

    .pillRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.04);
      font-size:12px; opacity:.95;
    }

    .btnRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:14px; align-items:center;}
    .btn{
      appearance:none; border:none;
      padding: 12px 14px; border-radius: 14px;
      cursor:pointer; color: var(--text);
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      transition: transform .08s ease, border-color .2s ease, background .2s ease, filter .2s ease;
      user-select:none; -webkit-tap-highlight-color: transparent;
    }
    .btn:hover{border-color: rgba(255,255,255,.22);}
    .btn:active{transform: translateY(1px) scale(.995);}
    .btn.primary{
      background: linear-gradient(90deg,
        color-mix(in oklab, var(--accent1) 85%, black 10%),
        color-mix(in oklab, var(--accent2) 80%, black 10%));
      border-color: rgba(255,255,255,.18);
      filter: saturate(1.08);
    }
    .btn.ghost{ background: rgba(255,255,255,.03); }
    .btn.danger{ background: rgba(255,107,107,.12); border-color: rgba(255,107,107,.40); }
    .btn:disabled{opacity:.45; cursor:not-allowed;}

    .toast{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      font-size: 12px;
      line-height:1.6;
      opacity:.92;
      white-space:pre-line;
    }
    .toast.ok{border-color: rgba(65,209,138,.35); background: rgba(65,209,138,.08);}
    .toast.bad{border-color: rgba(255,107,107,.35); background: rgba(255,107,107,.08);}
    .toast.warn{border-color: rgba(255,204,102,.35); background: rgba(255,204,102,.08);}

    label{display:block; font-size:12px; opacity:.88; margin-bottom:6px;}
    .field{
      width:100%;
      padding: 12px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline:none;
    }
    .field:focus{
      border-color: color-mix(in oklab, var(--accent2) 55%, white 0%);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--accent2) 18%, transparent);
    }
    .err{color:#ff6b6b; font-size:12px; margin-top:6px; line-height:1.5; display:none;}

    .qCard{
      padding: 16px;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(700px 280px at 10% 10%, color-mix(in oklab, var(--accent1) 18%, transparent), transparent 55%),
        radial-gradient(650px 260px at 90% 35%, color-mix(in oklab, var(--accent2) 12%, transparent), transparent 60%),
        rgba(255,255,255,.04);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
    }
    .qTop{display:flex; align-items:flex-start; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .qMeta{display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:12px; opacity:.92;}
    .chip{
      display:inline-flex; gap:8px; align-items:center;
      padding: 6px 10px; border-radius:999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      white-space:nowrap;
    }
    .chapterBadge{
      border-color: color-mix(in oklab, var(--accent1) 25%, rgba(255,255,255,.14));
      background: color-mix(in oklab, var(--accent1) 12%, rgba(255,255,255,.04));
    }
    .qText{margin:10px 0 0; font-size:15px; letter-spacing:.02em; line-height:1.7;}

    /* qTagは非表示（データ保持） */
    #qTagChip{ display:none !important; }

    .scaleWrap{
      margin-top: 14px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.14);
      padding: 14px 12px;
    }
    .scaleHead{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      font-size:12px; opacity:.92;
    }
    .valuePill{
      min-width: 44px; text-align:center; font-weight:700; font-size:13px;
      padding: 6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      box-shadow: 0 0 0 3px rgba(0,0,0,.10) inset;
    }

    .range{
      margin-top: 12px;
      width: 100%;
      -webkit-appearance: none;
      appearance: none;
      height: 12px;
      border-radius: 999px;
      outline:none;
      border: 1px solid rgba(255,255,255,.14);
      background:
        linear-gradient(90deg,
          var(--fillColor) 0%,
          var(--fillColor) var(--fillPct),
          rgba(255,255,255,.10) var(--fillPct),
          rgba(255,255,255,.10) 100%);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.10);
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .range::-webkit-slider-runnable-track{height:12px; border-radius:999px;}
    .range::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none;
      width:30px; height:30px; border-radius:999px;
      border: 1px solid rgba(255,255,255,.22);
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.96), rgba(255,255,255,.22) 40%, color-mix(in oklab, var(--fillColor) 70%, rgba(0,0,0,.10)) 75%),
        radial-gradient(circle at 70% 70%, rgba(255,255,255,.18), rgba(255,255,255,0) 62%);
      box-shadow:
        0 0 18px color-mix(in oklab, var(--fillColor) 40%, transparent),
        0 0 12px rgba(0,0,0,.25);
      margin-top: -9px;
      transform: scale(var(--thumbScale, 1));
      transition: transform .10s linear;
    }
    .range::-moz-range-track{
      height: 12px; border-radius:999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.14);
    }
    .range::-moz-range-thumb{
      width:30px; height:30px; border-radius:999px;
      border: 1px solid rgba(255,255,255,.22);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.96), rgba(255,255,255,.22) 40%, color-mix(in oklab, var(--fillColor) 70%, rgba(0,0,0,.10)) 75%);
      box-shadow: 0 0 18px color-mix(in oklab, var(--fillColor) 40%, transparent), 0 0 12px rgba(0,0,0,.25);
      transform: scale(var(--thumbScale, 1));
      transition: transform .10s linear;
    }

    .tickRow{margin-top:12px; display:grid; gap:6px;}
    .tickBtn{
      appearance:none; border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color: rgba(234,240,255,.88);
      border-radius: 12px;
      padding: 10px 0;
      font-size: 12px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .08s ease, border-color .2s ease, background .2s ease;
    }
    .tickBtn:active{ transform: translateY(1px) scale(.995); }
    .tickBtn.on{
      border-color: color-mix(in oklab, var(--fillColor) 55%, rgba(255,255,255,.12));
      background: color-mix(in oklab, var(--fillColor) 18%, rgba(255,255,255,.03));
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--fillColor) 14%, transparent);
      color: rgba(234,240,255,.96);
    }

    .bottomNav{
      position: fixed; left:0; right:0; bottom:0; z-index:60;
      padding: 10px 12px calc(10px + var(--safeBottom));
      background: linear-gradient(180deg, rgba(7,11,26,.10), rgba(7,11,26,.82));
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,.08);
    }
    .bottomNavInner{
      max-width:1180px; margin:0 auto;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .navLeft, .navRight{display:flex; gap:10px; align-items:center;}

    /* ===== Modals ===== */
    .modalBack{
      position: fixed; inset:0; z-index:200;
      background: rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center;
      padding: 18px;
    }
    .modal{
      width: min(560px, 96vw);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.16);
      background:
        radial-gradient(600px 240px at 20% 20%, color-mix(in oklab, var(--accent1) 22%, transparent), transparent 60%),
        radial-gradient(600px 240px at 80% 35%, color-mix(in oklab, var(--accent2) 16%, transparent), transparent 62%),
        rgba(10,14,36,.78);
      box-shadow: 0 18px 70px rgba(0,0,0,.55);
      padding: 18px;
      backdrop-filter: blur(14px);
      position:relative;
      overflow:hidden;
    }
    .modalGlow{
      position:absolute; inset:-60px -80px;
      background:
        radial-gradient(120px 80px at 20% 30%, rgba(255,255,255,.14), rgba(255,255,255,0) 70%),
        radial-gradient(120px 80px at 70% 50%, rgba(255,255,255,.10), rgba(255,255,255,0) 70%);
      animation: modalFloat 3.6s ease-in-out infinite;
      pointer-events:none;
    }
    @keyframes modalFloat{
      0%,100%{ transform: translateY(0px); opacity:.9; }
      50%{ transform: translateY(10px); opacity:1; }
    }
    .modalTitle{margin:0; font-size:16px; letter-spacing:.06em;}
    .modalBody{margin-top:10px; font-size:13px; line-height:1.8; opacity:.92;}
    .rewardRow{margin-top:12px; display:grid; grid-template-columns:1fr 1fr; gap:10px;}
    .reward{
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      padding: 10px;
      font-size:12px;
      line-height:1.6;
    }

    /* ===== Badges ===== */
    .badgeGrid{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      margin-top: 12px;
    }
    @media(min-width:720px){
      .badgeGrid{grid-template-columns: 1fr 1fr;}
    }
    .badgeCard{
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(520px 190px at 10% 20%, color-mix(in oklab, var(--accent1) 14%, transparent), transparent 60%),
        radial-gradient(520px 190px at 90% 30%, color-mix(in oklab, var(--accent2) 12%, transparent), transparent 62%),
        rgba(255,255,255,.04);
      padding: 12px;
      line-height: 1.7;
    }
    .badgeTitle{font-size:13px; font-weight:700; letter-spacing:.05em;}
    .badgeMeta{font-size:12px; opacity:.86; margin-top:4px;}
    .badgeDesc{font-size:12px; opacity:.92; margin-top:6px;}
    .badgeTagRow{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;}
    .badgeTag{
      font-size:11px;
      opacity:.92;
      padding: 5px 9px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.03);
      white-space:nowrap;
    }

    /* ===== Mini Map (常時表示) ===== */
    .miniMap{
      position: fixed;
      right: 12px;
      bottom: calc(78px + var(--safeBottom));
      z-index: 88;
      width: 120px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(10,14,36,.62);
      backdrop-filter: blur(12px);
      box-shadow: 0 14px 46px rgba(0,0,0,.45);
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      display:none;
    }
    .miniMapHeader{
      padding: 8px 10px 6px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .miniMapTitle{
      font-size:11px;
      letter-spacing:.08em;
      opacity:.90;
      white-space:nowrap;
    }
    .miniMapPct{
      font-size:11px;
      opacity:.92;
      font-weight:700;
    }
    .miniMapBody{
      padding: 6px 8px 10px;
    }
    .miniHint{
      font-size:10px;
      opacity:.72;
      padding: 0 10px 10px;
      line-height:1.4;
    }

    /* 画面が狭いときは少し小さく */
    @media (max-width: 380px){
      .miniMap{ width: 106px; right: 10px; }
    }

    .mapModal{
      width: min(720px, 96vw);
    }
    .mapModalSvgWrap{
      margin-top: 12px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }

    [hidden]{display:none !important;}
    .footer{text-align:center; margin-top:18px; font-size:12px; opacity:.78;}
  </style>
</head>

<body>
  <header class="topbar">
    <div class="topbarInner">
      <div class="brand">
        <div class="orb" aria-hidden="true"></div>
        <div>
          <h1 class="title">FortuneAI式 17タイプ診断</h1>
          <div class="subtitle" id="topSubtitle">100問×7段階で17タイプに分類。巡礼路で上昇</div>
        </div>
      </div>

      <div class="meter">
        <div class="waterBar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
          <div class="waterFill" id="waterFill"></div>
        </div>
        <div class="meterText" id="meterText">0 / 100</div>
      </div>
    </div>
  </header>

  <!-- Mini Map (常時表示) -->
  <div class="miniMap" id="miniMap" title="タップで地図を開く">
    <div class="miniMapHeader">
      <div class="miniMapTitle">巡礼路</div>
      <div class="miniMapPct" id="miniMapPct">0%</div>
    </div>
    <div class="miniMapBody">
      <svg id="miniMapSvg" viewBox="0 0 320 220" width="100%" height="110">
        <!-- JSで描画 -->
      </svg>
    </div>
    <div class="miniHint">タップで詳細</div>
  </div>

  <div class="wrap">
    <section class="card" id="viewHero">
      <h2 class="h1">診断を開始</h2>
      <p class="lead">
        20問ごとに章が切り替わり、ミニマップの建物が点灯します。進捗は右下の巡礼路で常に確認できます。
      </p>
      <div class="pillRow">
        <div class="pill">7段階（1〜7）</div>
        <div class="pill">ミニマップ常時</div>
        <div class="pill">章クリア演出</div>
        <div class="pill">単一HTML</div>
      </div>
      <div class="btnRow">
        <button class="btn primary" id="btnStart">開始</button>
        <button class="btn danger" id="btnResetAll">最初からやり直す（保存を消去）</button>
      </div>
    </section>

    <section class="card" id="viewProfile" hidden>
      <h2 class="h1">プロフィール</h2>
      <p class="lead muted small">※保存復元あり。userIdはURL（?userId=...）でも渡せます。</p>

      <div class="grid2" style="margin-top:12px;">
        <div>
          <label for="name">表示名（必須）</label>
          <input class="field" id="name" type="text" placeholder="例：太郎" />
          <div class="err" id="errName">表示名を入力してください。</div>

          <div style="height:12px;"></div>

          <label for="gender">性別（必須）</label>
          <select class="field" id="gender">
            <option value="">選択してください</option>
            <option value="male">male（男性）</option>
            <option value="female">female（女性）</option>
            <option value="other">other（その他）</option>
          </select>
          <div class="err" id="errGender">性別を選択してください。</div>

          <div style="height:12px;"></div>

          <label for="birthday">生年月日（必須）</label>
          <input class="field" id="birthday" type="date" />
          <div class="err" id="errBirthday">生年月日を入力してください。</div>

          <div style="height:12px;"></div>

          <label for="userId">userId（任意）</label>
          <input class="field" id="userId" type="text" placeholder="例：Uxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" />

          <div class="btnRow">
            <button class="btn ghost" id="btnBackToHero">戻る</button>
            <button class="btn primary" id="btnToQuestions">回答へ進む</button>
          </div>

          <div class="toast warn" id="profileRestoreNote" style="display:none;">
            保存データを検出しました。プロフィール・回答・進捗を復元しています。
          </div>
        </div>

        <div class="sideStack">
          <div class="card" style="margin:0; box-shadow:none;">
            <h3 class="h1" style="font-size:14px;">Make連携</h3>
            <p class="lead muted small">
              最終送信で <code>final_submit</code> JSON を生成し、WEBHOOK_URL が設定されていればPOSTします。<br>
              payloadに <code>typeCode</code> と <code>scores(E,S,T,J)</code> を同梱します。
            </p>
            <div class="miniLine"></div>
            <p class="lead muted small" style="margin:0;">
              「次へ」は未回答を自動追跡（離脱防止）。
            </p>
          </div>
        </div>
      </div>
    </section>

    <section class="card" id="viewQuestions" hidden>
      <div class="grid2">
        <div class="qCard">
          <div class="qTop">
            <div class="qMeta">
              <span class="chip chapterBadge" id="chapterChip">CHAPTER 1 / 5</span>
              <span class="chip" id="qIndexChip">Q 1 / 100</span>
              <span class="chip" id="qTagChip">[S+]</span> <!-- 非表示 -->
            </div>
            <div class="qMeta">
              <span class="chip">完了 <strong id="doneCountText">0</strong></span>
              <span class="chip">現在 <strong id="currentValueText">4</strong></span>
              <span class="chip">状態 <strong id="answerStateText">未</strong></span>
            </div>
          </div>

          <div class="qText" id="qText">Q1. （設問）</div>

          <div class="scaleWrap">
            <div class="scaleHead">
              <span id="leftScaleLabel">1 = まったくそう思わない</span>
              <span class="valuePill" id="valuePill">4</span>
              <span id="rightScaleLabel">7 = 非常にそう思う</span>
            </div>

            <input id="range" class="range" type="range" min="1" max="7" step="1" value="4" />

            <div class="tickRow" id="tickRow"></div>
          </div>

          <div class="toast" id="qToast" style="display:none;"></div>

          <div class="sep"></div>

          <div class="btnRow">
            <button class="btn ghost" id="btnOpenMap">地図（詳細）</button>
            <button class="btn ghost" id="btnJumpProfile">プロフィールへ戻る</button>
            <button class="btn ghost" id="btnJumpFirstUnanswered">未回答へ移動</button>
            <button class="btn danger" id="btnResetFromQuestions">最初からやり直す（保存を消去）</button>
          </div>
        </div>

        <div class="sideStack">
          <section class="card" style="margin:0; box-shadow:none;">
            <h3 class="h1" style="font-size:14px; margin:0;">仕様</h3>
            <div class="muted small" style="margin-top:8px; line-height:1.7;">
              ・7段階（1〜7）<br>
              ・ミニマップ常時表示（右下）<br>
              ・章クリア（20問ごと）で演出と称号獲得<br>
              ・未回答が残る限り、次へは未回答へ誘導
            </div>
          </section>
        </div>
      </div>
    </section>

    <section class="card" id="viewWorry" hidden>
      <h2 class="h1">悩み入力</h2>
      <p class="lead">最終送信payloadの <code>worryText</code> に入ります（最大2000文字）。</p>
      <label for="worryText" style="margin-top:12px;">悩み</label>
      <textarea class="field" id="worryText" maxlength="2000" style="min-height:160px; resize:vertical; line-height:1.6;"></textarea>

      <div class="btnRow" style="justify-content:space-between;">
        <div class="muted small" id="worryCount">0 / 2000</div>
        <button class="btn primary" id="btnShowResult">結果を見る</button>
      </div>
    </section>

    <section class="card" id="viewResult" hidden>
      <h2 class="h1">結果</h2>
      <div class="sep"></div>

      <div class="toast" id="resultToast" style="display:none;"></div>

      <div id="badgeSection" style="display:none;">
        <p class="lead"><b>獲得称号（章クリア報酬）</b></p>
        <div class="badgeGrid" id="badgeGrid"></div>
        <div class="sep"></div>
      </div>

      <div class="btnRow">
        <button class="btn primary" id="btnFinalSubmit">最終送信（final_submit）</button>
        <button class="btn ghost" id="btnCopyJson">JSONをコピー</button>
        <button class="btn ghost" id="btnDownloadJson">JSONをダウンロード</button>
        <button class="btn ghost" id="btnOpenMap2">地図（詳細）</button>
        <button class="btn danger" id="btnResetFromResult">最初からやり直す（保存を消去）</button>
      </div>

      <div id="jsonPreviewWrap" style="display:none;">
        <div class="sep"></div>
        <p class="lead"><b>JSONプレビュー（WEBHOOK_URL未設定時）</b></p>
        <pre class="field" id="jsonPreview" style="max-height:320px; overflow:auto; white-space:pre; font-size:11.5px; line-height:1.55;"></pre>
      </div>
    </section>

    <div class="footer">© FortuneAI / 本ページは単一ファイル構成（外部ライブラリ不使用）</div>
  </div>

  <div class="bottomNav" id="bottomNav" style="display:none;">
    <div class="bottomNavInner">
      <div class="navLeft">
        <button class="btn ghost" id="btnPrevQ">前へ</button>
      </div>
      <div class="navRight">
        <button class="btn primary" id="btnNextQ">次へ</button>
      </div>
    </div>
  </div>

  <!-- 章クリアモーダル -->
  <div class="modalBack" id="chapterModal" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modalGlow" aria-hidden="true"></div>
      <h3 class="modalTitle" id="chapterModalTitle">CHAPTER CLEAR</h3>
      <div class="modalBody" id="chapterModalBody"></div>

      <div class="rewardRow">
        <div class="reward" id="reward1"></div>
        <div class="reward" id="reward2"></div>
      </div>

      <div class="btnRow" style="justify-content:flex-end;">
        <button class="btn primary" id="btnChapterContinue">次の章へ</button>
      </div>
    </div>
  </div>

  <!-- 地図詳細モーダル -->
  <div class="modalBack" id="mapModal" aria-hidden="true">
    <div class="modal mapModal" role="dialog" aria-modal="true">
      <div class="modalGlow" aria-hidden="true"></div>
      <h3 class="modalTitle">巡礼路（詳細）</h3>
      <div class="modalBody" id="mapModalBody">精霊は現在位置。建物は20問ごとの章ポイント（点灯で到達）。</div>

      <div class="mapModalSvgWrap">
        <svg id="mapModalSvg" viewBox="0 0 320 220" width="100%" height="320"></svg>
      </div>

      <div class="btnRow" style="justify-content:flex-end;">
        <button class="btn primary" id="btnCloseMap">閉じる</button>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * ここだけ編集（MakeのWebhook）
     ***********************/
    const WEBHOOK_URL = "https://hook.eu2.make.com/7ac62r32ffup0cl0d1kr9h3dpbf8dz3h";
    const STORAGE_KEY = "fortuneai_17type_mystic_ascent_singlefile";

    /***********************
     * 7段階スケール（1..7）
     ***********************/
    const SCALE_MIN = 1;
    const SCALE_MAX = 7;
    const SCALE_MID = 4; // 中央（中立）
    const AXIS_MAX = 75; // 25問×最大3 = 75
    const BAL_THRESHOLD = 10; // “均衡”の閾値（7段階用）

    const THEMES = [
      { name:"CHAPTER 1 / 5", a1:"#7c4dff", a2:"#cfa76e", a3:"#43d3ff", bg0:"#070b1a", bg1:"#0b1231" },
      { name:"CHAPTER 2 / 5", a1:"#43d3ff", a2:"#7c4dff", a3:"#cfa76e", bg0:"#06101a", bg1:"#071a2b" },
      { name:"CHAPTER 3 / 5", a1:"#cfa76e", a2:"#43d3ff", a3:"#7c4dff", bg0:"#120c0a", bg1:"#0b1231" },
      { name:"CHAPTER 4 / 5", a1:"#ff6bd6", a2:"#43d3ff", a3:"#cfa76e", bg0:"#0d0616", bg1:"#08163a" },
      { name:"CHAPTER 5 / 5", a1:"#41d18a", a2:"#cfa76e", a3:"#7c4dff", bg0:"#060f0d", bg1:"#081a2b" },
    ];

    const TYPE_TITLES = {
      "INTJ":"FortuneAI：黒曜アーキテクト（戦略設計者）",
      "INTP":"FortuneAI：蒼天アナリスト（原理解剖者）",
      "ENTJ":"FortuneAI：紅蓮コマンダー（成果指揮者）",
      "ENTP":"FortuneAI：雷光インベンター（変革発明者）",
      "INFJ":"FortuneAI：星導シーア（未来洞察者）",
      "INFP":"FortuneAI：月影バード（理想詩人）",
      "ENFJ":"FortuneAI：旭日メンター（覚醒導師）",
      "ENFP":"FortuneAI：虹彩オラクル（可能性点火者）",
      "ISTJ":"FortuneAI：鉄律マーシャル（秩序監督者）",
      "ISFJ":"FortuneAI：守灯スチュワード（献身支援者）",
      "ESTJ":"FortuneAI：白鋼マーシャル（現場統制者）",
      "ESFJ":"祝祭ホスト（調和演出者）",
      "ISTP":"影刃スミス（実務解体者）",
      "ISFP":"花晶アーティザン（美感匠）",
      "ESTP":"疾風ストライカー（機会攻略者）",
      "ESFP":"陽光パフォーマー（感情起動者）",
      "BAL":"均衡アルケミスト（統合適応者）"
    };

    const TAROT_MAJOR = {
      "INTJ":"隠者","INTP":"正義","ENTJ":"皇帝","ENTP":"魔術師","INFJ":"女教皇","INFP":"星","ENFJ":"太陽","ENFP":"愚者",
      "ISTJ":"教皇","ISFJ":"節制","ESTJ":"戦車","ESFJ":"女帝","ISTP":"力","ISFP":"恋人","ESTP":"運命の輪","ESFP":"世界","BAL":"審判"
    };

    const BADGE_DEFS = [
      { milestone:20, title:"第一章の証印", meta:"CHAPTER 1 CLEAR（20/100）", desc:"巡礼路が定着。あなたの意志が軌道に乗り始める。", tags:["ルーン点灯","集中+1"] },
      { milestone:40, title:"第二章の紋章", meta:"CHAPTER 2 CLEAR（40/100）", desc:"判断が研ぎ澄まされる。躊躇が減り、反応が速くなる。", tags:["安定化","決断+1"] },
      { milestone:60, title:"第三章の聖鍵", meta:"CHAPTER 3 CLEAR（60/100）", desc:"複雑性を統合。矛盾を矛盾のまま扱える強さが生まれる。", tags:["統合","俯瞰+1"] },
      { milestone:80, title:"第四章の星核", meta:"CHAPTER 4 CLEAR（80/100）", desc:"最後の抵抗帯を突破。自分の型が輪郭として現れる。", tags:["突破","自信+1"] },
      { milestone:100, title:"終章の冠", meta:"CHAPTER 5 CLEAR（100/100）", desc:"到達。結果の統合処理が解放され、称号が確定する。", tags:["到達","完成"] },
    ];

    /***********************
     * 設問100（固定）
     ***********************/
    const QUESTIONS = buildDefaultQuestions();
    function buildDefaultQuestions(){
      const out = [];
      const mk = (id, text, tag) => ({ id, text, tag });
      const E = [
        ["初対面の場でも、自然に話しかけるほうだ","[E+]"],
        ["一人で過ごす時間が長いほど安心する","[E-]"],
        ["人が集まる場に行くとエネルギーが湧く","[E+]"],
        ["雑談よりも、必要な会話だけで十分だ","[E-]"],
        ["相談されると、すぐ反応して場を動かしたくなる","[E+]"],
        ["予定が詰まると、まず距離を取りたくなる","[E-]"],
        ["新しいコミュニティに入るのが楽しみだ","[E+]"],
        ["考えをまとめてからでないと発言しにくい","[E-]"],
        ["人前で話すことに抵抗が少ない","[E+]"],
        ["大勢の中にいるより、少人数が落ち着く","[E-]"],
        ["即興で会話を広げるのが得意だ","[E+]"],
        ["会話の後は、一人で回復する時間が必要だ","[E-]"],
        ["周囲のテンションに合わせて盛り上げられる","[E+]"],
        ["発言前に、頭の中で何度もシミュレーションする","[E-]"],
        ["場の空気を読んで率先して動く","[E+]"],
        ["自分の世界に入る時間がないと消耗する","[E-]"],
        ["他人と一緒に作業する方が捗る","[E+]"],
        ["連絡は最低限でいいと感じる","[E-]"],
        ["新しい人脈作りに前向きだ","[E+]"],
        ["静かな環境の方が集中できる","[E-]"],
        ["反応が返ってくるやり取りが好きだ","[E+]"],
        ["自分の内側で結論が出るまで話したくない","[E-]"],
        ["イベントや集まりを企画するのが好きだ","[E+]"],
        ["社交の後は疲れがどっと出る","[E-]"],
        ["人と話すほどアイデアが出る","[E+]"],
      ];
      const S = [
        ["事実や実例をもとに判断することが多い","[S+]"],
        ["抽象的な可能性を考えるのが好きだ","[S-]"],
        ["今ある情報を丁寧に確認して進めたい","[S+]"],
        ["『もし〜なら』の仮説を立てるのが楽しい","[S-]"],
        ["手順や具体策を固めると安心する","[S+]"],
        ["細部より全体像や意味を先に掴みたい","[S-]"],
        ["現実的な制約を踏まえて決める","[S+]"],
        ["直感的なひらめきで方向性を決めることがある","[S-]"],
        ["経験に基づく再現性を重視する","[S+]"],
        ["未来のトレンドや流れを想像しやすい","[S-]"],
        ["数字や根拠があると納得しやすい","[S+]"],
        ["曖昧でもビジョンがあれば動ける","[S-]"],
        ["具体的な改善点を列挙できる","[S+]"],
        ["象徴や比喩で理解する方がしっくりくる","[S-]"],
        ["現場感覚や実務の感触を大切にする","[S+]"],
        ["今は無い可能性にワクワクする","[S-]"],
        ["計画は現実に落とし込めるかを確認する","[S+]"],
        ["常識を疑って新しい解釈を探す","[S-]"],
        ["目の前の課題を一つずつ解くのが得意","[S+]"],
        ["パターンや共通点を見つけるのが得意","[S-]"],
        ["具体例があると理解が早い","[S+]"],
        ["コンセプトや世界観から発想する","[S-]"],
        ["小さな変化に気づきやすい","[S+]"],
        ["本質を掴めば細部は後からでいい","[S-]"],
        ["現実のリスクを先に洗い出す","[S+]"],
      ];
      const T = [
        ["結論は論理の整合性を優先したい","[T+]"],
        ["相手の気持ちを優先して言い方を選ぶ","[T-]"],
        ["公平なルールに沿って判断したい","[T+]"],
        ["衝突を避けるために配慮することが多い","[T-]"],
        ["感情よりも事実を先に整理する","[T+]"],
        ["場の雰囲気や人間関係を重視する","[T-]"],
        ["効率や成果を基準に意思決定する","[T+]"],
        ["相手が傷つかないことが最重要だ","[T-]"],
        ["議論で弱点を指摘されても冷静でいられる","[T+]"],
        ["共感されると安心する","[T-]"],
        ["原因と結果を分解して考える","[T+]"],
        ["誰かの努力や背景を汲み取りたい","[T-]"],
        ["正しい/間違いをはっきりさせたい","[T+]"],
        ["『正しさ』より『やさしさ』を優先する","[T-]"],
        ["合理性が低い提案は見直したくなる","[T+]"],
        ["相手の立場に立つと決めきれないことがある","[T-]"],
        ["数字で説明できると安心する","[T+]"],
        ["感情の納得感がないと進めにくい","[T-]"],
        ["評価基準を明確にしてから動く","[T+]"],
        ["和を乱さないように調整するのが得意","[T-]"],
        ["長期的に得かどうかで選ぶ","[T+]"],
        ["関係性が壊れそうなら方針を変える","[T-]"],
        ["最適解を探すのが好きだ","[T+]"],
        ["相手が安心できる説明を心がける","[T-]"],
        ["結論を急がず気持ちを整える時間も必要","[T-]"],
      ];
      const J = [
        ["締切や計画がある方が動きやすい","[J+]"],
        ["選択肢を残しておきたい","[J-]"],
        ["ToDoを整理して順番に処理する","[J+]"],
        ["その場の流れで柔軟に決めたい","[J-]"],
        ["予定は早めに確定したい","[J+]"],
        ["直前まで迷って最良を選びたい","[J-]"],
        ["ルールや手順に沿って進めたい","[J+]"],
        ["型にハマらず試行錯誤したい","[J-]"],
        ["部屋やデータは整っている方が落ち着く","[J+]"],
        ["散らかっていても必要ならすぐ動ける","[J-]"],
        ["決めたら最後までやり切りたい","[J+]"],
        ["状況次第で方針を変えるのが自然だ","[J-]"],
        ["まずゴールと期限を決める","[J+]"],
        ["やりながら目的が変わることもある","[J-]"],
        ["手帳やメモで管理する習慣がある","[J+]"],
        ["計画よりも勢いが大事だと思う","[J-]"],
        ["『完了』の状態を作るのが好きだ","[J+]"],
        ["未完成でも進めながら整えたい","[J-]"],
        ["予想外が起きてもリカバリ計画を立てる","[J+]"],
        ["選択肢が多いほどワクワクする","[J-]"],
        ["チェックリストがあると安心する","[J+]"],
        ["締切がないと面白い方へ寄り道する","[J-]"],
        ["先に段取りを決めてから動く","[J+]"],
        ["その時の気分で優先順位が変わる","[J-]"],
        ["結論を早めに固めてスッキリしたい","[J+]"],
      ];
      let id = 1;
      for (const [t, tag] of E) out.push(mk(id++, `Q${id-1}. ${t}`, tag));
      for (const [t, tag] of S) out.push(mk(id++, `Q${id-1}. ${t}`, tag));
      for (const [t, tag] of T) out.push(mk(id++, `Q${id-1}. ${t}`, tag));
      for (const [t, tag] of J) out.push(mk(id++, `Q${id-1}. ${t}`, tag));
      if (out.length !== 100) throw new Error("QUESTIONS must be 100");
      return out;
    }

    const $ = (id)=>document.getElementById(id);

    const dom = {
      viewHero:$("viewHero"),
      viewProfile:$("viewProfile"),
      viewQuestions:$("viewQuestions"),
      viewWorry:$("viewWorry"),
      viewResult:$("viewResult"),

      btnStart:$("btnStart"),
      btnResetAll:$("btnResetAll"),

      btnBackToHero:$("btnBackToHero"),
      btnToQuestions:$("btnToQuestions"),

      name:$("name"),
      gender:$("gender"),
      birthday:$("birthday"),
      userId:$("userId"),
      errName:$("errName"),
      errGender:$("errGender"),
      errBirthday:$("errBirthday"),
      profileRestoreNote:$("profileRestoreNote"),

      qText:$("qText"),
      qTagChip:$("qTagChip"),
      qIndexChip:$("qIndexChip"),
      chapterChip:$("chapterChip"),
      doneCountText:$("doneCountText"),
      currentValueText:$("currentValueText"),
      valuePill:$("valuePill"),
      range:$("range"),
      tickRow:$("tickRow"),
      qToast:$("qToast"),

      btnPrevQ:$("btnPrevQ"),
      btnNextQ:$("btnNextQ"),
      btnJumpProfile:$("btnJumpProfile"),
      btnJumpFirstUnanswered:$("btnJumpFirstUnanswered"),
      btnResetFromQuestions:$("btnResetFromQuestions"),
      btnOpenMap:$("btnOpenMap"),

      bottomNav:$("bottomNav"),

      worryText:$("worryText"),
      worryCount:$("worryCount"),
      btnShowResult:$("btnShowResult"),

      btnFinalSubmit:$("btnFinalSubmit"),
      btnCopyJson:$("btnCopyJson"),
      btnDownloadJson:$("btnDownloadJson"),
      btnResetFromResult:$("btnResetFromResult"),
      btnOpenMap2:$("btnOpenMap2"),
      resultToast:$("resultToast"),
      jsonPreviewWrap:$("jsonPreviewWrap"),
      jsonPreview:$("jsonPreview"),

      badgeSection:$("badgeSection"),
      badgeGrid:$("badgeGrid"),

      waterFill:$("waterFill"),
      meterText:$("meterText"),
      topSubtitle:$("topSubtitle"),

      chapterModal:$("chapterModal"),
      chapterModalTitle:$("chapterModalTitle"),
      chapterModalBody:$("chapterModalBody"),
      btnChapterContinue:$("btnChapterContinue"),
      reward1:$("reward1"),
      reward2:$("reward2"),

      leftScaleLabel:$("leftScaleLabel"),
      rightScaleLabel:$("rightScaleLabel"),
      answerStateText:$("answerStateText"),

      miniMap:$("miniMap"),
      miniMapSvg:$("miniMapSvg"),
      miniMapPct:$("miniMapPct"),

      mapModal:$("mapModal"),
      mapModalSvg:$("mapModalSvg"),
      mapModalBody:$("mapModalBody"),
      btnCloseMap:$("btnCloseMap"),
    };

    const state = {
      view:"hero",
      currentIndex:0,
      profile:{ name:"", gender:"", birthday:"" },
      userId:"",
      answers:new Array(100).fill(SCALE_MID),
      done:new Array(100).fill(false),
      worryText:"",
      lastPayload:null,
      lastChapterShown:0,
      badges:[],
      mapReady:false
    };

    // range属性を強制確定
    dom.range.min = String(SCALE_MIN);
    dom.range.max = String(SCALE_MAX);
    dom.range.step = "1";
    dom.leftScaleLabel.textContent = `${SCALE_MIN} = まったくそう思わない`;
    dom.rightScaleLabel.textContent = `${SCALE_MAX} = 非常にそう思う`;

    const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));

    function parseQuery(){
      const q = new URLSearchParams(location.search);
      return { userId: q.get("userId") || "" };
    }

    function save(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        view:state.view,
        currentIndex:state.currentIndex,
        profile:state.profile,
        userId:state.userId,
        answers:state.answers,
        done:state.done,
        worryText:state.worryText,
        lastChapterShown:state.lastChapterShown,
        badges:state.badges
      }));
    }

    // 9段階→7段階の自動マイグレーション
    function migrateAnswersIfNeeded(arr){
      let maxV = 0;
      for (const v of arr) maxV = Math.max(maxV, Number(v || 0));
      if (maxV <= SCALE_MAX) return arr.map(v => clamp(Number(v ?? SCALE_MID), SCALE_MIN, SCALE_MAX));

      // 1..9 を 1..7 に圧縮（丸め）
      // new = round((old-1)*(6/8)+1)
      return arr.map(v=>{
        const ov = clamp(Number(v ?? 5), 1, 9);
        const nv = Math.round((ov - 1) * (6/8) + 1);
        return clamp(nv, SCALE_MIN, SCALE_MAX);
      });
    }

    function load(){
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      try{
        const data = JSON.parse(raw);
        if (!data || typeof data !== "object") return false;
        if (!Array.isArray(data.answers) || data.answers.length !== 100) return false;

        state.view = data.view || "hero";
        state.currentIndex = clamp(Number(data.currentIndex || 0), 0, 99);

        state.profile = {
          name: String(data.profile?.name || ""),
          gender: String(data.profile?.gender || ""),
          birthday: String(data.profile?.birthday || ""),
        };
        state.userId = String(data.userId || "");

        state.answers = migrateAnswersIfNeeded(data.answers);

        if (Array.isArray(data.done) && data.done.length === 100){
          state.done = data.done.map(Boolean);
        } else {
          state.done = new Array(100).fill(false);
        }

        state.worryText = String(data.worryText || "");
        state.lastChapterShown = Number(data.lastChapterShown || 0);

        if (Array.isArray(data.badges)){
          state.badges = data.badges
            .filter(x => x && typeof x === "object" && Number.isFinite(Number(x.milestone)))
            .map(x => ({
              milestone:Number(x.milestone),
              title:String(x.title||""),
              meta:String(x.meta||""),
              desc:String(x.desc||""),
              tags:Array.isArray(x.tags)? x.tags.map(String): [],
              at:Number(x.at||Date.now())
            }));
        } else {
          state.badges = [];
        }

        return true;
      }catch{
        return false;
      }
    }

    function clearAll(){
      localStorage.removeItem(STORAGE_KEY);
      state.view="hero";
      state.currentIndex=0;
      state.profile={name:"",gender:"",birthday:""};
      state.userId="";
      state.answers=new Array(100).fill(SCALE_MID);
      state.done=new Array(100).fill(false);
      state.worryText="";
      state.lastPayload=null;
      state.lastChapterShown=0;
      state.badges=[];
      renderAll();
    }

    function setView(v){
      state.view=v;
      save();
      renderAll();
      window.scrollTo({top:0, behavior:"smooth"});
    }

    function answeredDoneCount(){ return state.done.reduce((a,b)=>a+(b?1:0),0); }
    function unansweredCount(){ return state.done.reduce((a,b)=>a+(b?0:1),0); }
    function firstUnansweredIndex(){ return state.done.findIndex(x=>!x); }
    function nextUnansweredIndex(from){
      for (let i=from+1;i<100;i++){ if (!state.done[i]) return i; }
      return -1;
    }
    function allAnswered(){ return answeredDoneCount() === 100; }

    function currentChapterByDone(doneCount){ return clamp(Math.floor(doneCount/20), 0, 4); }

    function applyThemeByDone(doneCount){
      const th = THEMES[currentChapterByDone(doneCount)];
      document.documentElement.style.setProperty("--accent1", th.a1);
      document.documentElement.style.setProperty("--accent2", th.a2);
      document.documentElement.style.setProperty("--accent3", th.a3);
      document.documentElement.style.setProperty("--bg0", th.bg0);
      document.documentElement.style.setProperty("--bg1", th.bg1);
      dom.chapterChip.textContent = th.name;
      dom.topSubtitle.textContent = `章：${th.name}｜巡礼路で上昇（7段階）`;
    }

    function updateMeter(){
      const done = answeredDoneCount();
      const pct = (done/100)*100;
      dom.waterFill.style.width = pct.toFixed(1) + "%";
      dom.meterText.textContent = `${done} / 100`;
      dom.waterFill.parentElement.setAttribute("aria-valuenow", String(done));
      applyThemeByDone(done);

      // mini map
      dom.miniMapPct.textContent = `${Math.round(pct)}%`;
      updateMapAll(done);
      updateMiniMapVisibility();
    }

    function updateMiniMapVisibility(){
      // hero以外（プロフィール以降）で常時表示
      const show = (state.view !== "hero");
      dom.miniMap.style.display = show ? "block" : "none";
    }

    function valueColor(v){
      const vv = clamp(v, SCALE_MIN, SCALE_MAX);
      // 7段階の色分け（中心=4）
      const map = {
        1: "color-mix(in oklab, var(--accent1) 84%, black 12%)",
        2: "color-mix(in oklab, var(--accent1) 68%, var(--accent3) 18%)",
        3: "color-mix(in oklab, var(--accent3) 62%, var(--accent1) 22%)",
        4: "color-mix(in oklab, var(--accent3) 54%, rgba(255,255,255,.10) 0%)",
        5: "color-mix(in oklab, var(--accent2) 52%, var(--accent3) 26%)",
        6: "color-mix(in oklab, var(--accent2) 72%, var(--accent3) 12%)",
        7: "color-mix(in oklab, var(--accent2) 88%, white 6%)",
      };
      return map[vv] || map[SCALE_MID];
    }

    function applyThumbScale(v){
      const dist = Math.abs(v - SCALE_MID); // 0..3
      const t = dist / (SCALE_MAX - SCALE_MID); // 0..1
      dom.range.style.setProperty("--thumbScale", String(1 + t*0.42));
    }

    function applyRangePaint(v){
      const pct = ((v - SCALE_MIN) / (SCALE_MAX - SCALE_MIN)) * 100;
      dom.range.style.setProperty("--fillPct", pct.toFixed(2) + "%");
      dom.range.style.setProperty("--fillColor", valueColor(v));
      dom.valuePill.textContent = String(v);
      dom.currentValueText.textContent = String(v);
      applyThumbScale(v);

      dom.tickRow.querySelectorAll("button[data-v]").forEach(b=>{
        b.classList.toggle("on", Number(b.dataset.v) === v);
      });

      const i = state.currentIndex;
      dom.answerStateText.textContent = state.done[i] ? "済" : "未";
    }

    function renderTicks(current){
      dom.tickRow.innerHTML = "";
      dom.tickRow.style.gridTemplateColumns = `repeat(${SCALE_MAX - SCALE_MIN + 1}, 1fr)`;
      for (let v=SCALE_MIN; v<=SCALE_MAX; v++){
        const b = document.createElement("button");
        b.type="button";
        b.className = "tickBtn" + (v===current ? " on" : "");
        b.textContent = String(v);
        b.dataset.v = String(v);
        b.addEventListener("click", ()=> setAnswerValue(v, true));
        dom.tickRow.appendChild(b);
      }
    }

    function showQToast(msg, kind="warn"){
      dom.qToast.className = "toast " + (kind==="ok"?"ok":kind==="bad"?"bad":"warn");
      dom.qToast.textContent = msg;
      dom.qToast.style.display="block";
      setTimeout(()=>{ dom.qToast.style.display="none"; }, 1600);
    }

    function setAnswerValue(v, markDone){
      const i = state.currentIndex;
      const val = clamp(Number(v), SCALE_MIN, SCALE_MAX);
      state.answers[i] = val;
      if (markDone) state.done[i] = true;
      save();
      dom.range.value = String(val);
      applyRangePaint(val);
      dom.doneCountText.textContent = String(answeredDoneCount());
      updateMeter();
      maybeShowChapterClear();
    }

    function validateProfile(){
      let ok = true;
      dom.errName.style.display="none";
      dom.errGender.style.display="none";
      dom.errBirthday.style.display="none";
      if (!dom.name.value.trim()){ dom.errName.style.display="block"; ok=false; }
      if (!dom.gender.value){ dom.errGender.style.display="block"; ok=false; }
      if (!dom.birthday.value){ dom.errBirthday.style.display="block"; ok=false; }
      return ok;
    }

    function syncProfileFromInputs(){
      state.profile.name = dom.name.value.trim();
      state.profile.gender = dom.gender.value;
      state.profile.birthday = dom.birthday.value;
      state.userId = dom.userId.value.trim();
      save();
    }

    // 7段階: 1..7 -> -3..+3（中心=4）
    function answerToValue(ans){ return (Number(ans) - SCALE_MID); }

    function applyTagToAxis(tag, val, scores){
      const m = String(tag).match(/\[([ESTJ])([+-])\]/);
      if (!m) return;
      const axis = m[1];
      const sign = m[2];
      const v = (sign === "+") ? val : -val;
      if (axis==="E") scores.E += v;
      if (axis==="S") scores.S += v;
      if (axis==="T") scores.T += v;
      if (axis==="J") scores.J += v;
    }

    function computeScores(){
      const scores = {E:0,S:0,T:0,J:0};
      for (let i=0;i<100;i++){
        const val = answerToValue(state.answers[i]);
        applyTagToAxis(QUESTIONS[i].tag, val, scores);
      }
      scores.E = clamp(scores.E, -AXIS_MAX, AXIS_MAX);
      scores.S = clamp(scores.S, -AXIS_MAX, AXIS_MAX);
      scores.T = clamp(scores.T, -AXIS_MAX, AXIS_MAX);
      scores.J = clamp(scores.J, -AXIS_MAX, AXIS_MAX);
      return scores;
    }

    function computeType(scores){
      const absE = Math.abs(scores.E), absS=Math.abs(scores.S), absT=Math.abs(scores.T), absJ=Math.abs(scores.J);
      const isBAL = (absE < BAL_THRESHOLD && absS < BAL_THRESHOLD && absT < BAL_THRESHOLD && absJ < BAL_THRESHOLD);
      if (isBAL) return { typeCode:"BAL", isBAL:true };
      const EorI = (scores.E >= 0) ? "E" : "I";
      const SorN = (scores.S >= 0) ? "S" : "N";
      const TorF = (scores.T >= 0) ? "T" : "F";
      const JorP = (scores.J >= 0) ? "J" : "P";
      return { typeCode: (EorI+SorN+TorF+JorP), isBAL:false };
    }

    function buildPayload(){
      if (!allAnswered()){
        const idx = firstUnansweredIndex();
        throw new Error(`未回答があります（Q${idx+1}）`);
      }

      const scores = computeScores();
      const t = computeType(scores);

      const payload = {
        action:"final_submit",
        userId: (state.userId || "").trim(),
        step:999,
        profile:{
          gender: state.profile.gender,
          name: state.profile.name,
          birthday: state.profile.birthday
        },
        answers: state.answers.map(v => Number(v)),
        worryText: state.worryText || "",
        typeCode: t.typeCode,
        scores: { E:scores.E, S:scores.S, T:scores.T, J:scores.J }
      };

      if (!payload.profile.name || !payload.profile.gender || !payload.profile.birthday) throw new Error("profile incomplete");
      if (!Array.isArray(payload.answers) || payload.answers.length !== 100) throw new Error("answers invalid");
      for (const a of payload.answers){
        if (!Number.isInteger(a) || a<SCALE_MIN || a>SCALE_MAX) throw new Error(`answers must be ${SCALE_MIN}..${SCALE_MAX} integers`);
      }
      if (payload.worryText.length > 2000) payload.worryText = payload.worryText.slice(0,2000);
      return payload;
    }

    function safeJson(obj){ return JSON.stringify(obj, null, 2); }

    async function copyToClipboard(text){
      try{ await navigator.clipboard.writeText(text); return true; }
      catch{
        const ta = document.createElement("textarea");
        ta.value=text; ta.style.position="fixed"; ta.style.left="-9999px";
        document.body.appendChild(ta); ta.focus(); ta.select();
        let ok=false; try{ ok=document.execCommand("copy"); }catch{ ok=false; }
        ta.remove(); return ok;
      }
    }

    function downloadText(filename, text){
      const blob = new Blob([text], {type:"application/json;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href=url; a.download=filename;
      document.body.appendChild(a);
      a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    async function finalSubmit(){
      dom.resultToast.style.display="none";
      let payload;
      try{ payload = buildPayload(); }
      catch(e){
        dom.resultToast.className="toast bad";
        dom.resultToast.textContent="送信前チェックに失敗しました： " + (e?.message || e);
        dom.resultToast.style.display="block";
        return;
      }
      state.lastPayload = payload;
      save();

      const jsonText = safeJson(payload);

      if (!WEBHOOK_URL){
        dom.jsonPreviewWrap.style.display="block";
        dom.jsonPreview.textContent = jsonText;
        dom.resultToast.className="toast warn";
        dom.resultToast.textContent="WEBHOOK_URL未設定のため送信せず、JSONを表示しました。";
        dom.resultToast.style.display="block";
        return;
      }

      dom.resultToast.className="toast";
      dom.resultToast.textContent="送信中…";
      dom.resultToast.style.display="block";

      try{
        const res = await fetch(WEBHOOK_URL, {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: jsonText
        });
        if (!res.ok){
          const body = await res.text().catch(()=> "");
          dom.resultToast.className="toast bad";
          dom.resultToast.textContent=`送信失敗：HTTP ${res.status}\n${body ? body.slice(0,400) : ""}`;
          return;
        }
        const body = await res.text().catch(()=> "");
        dom.resultToast.className="toast ok";
        dom.resultToast.textContent=`送信成功：HTTP ${res.status}\n${body ? body.slice(0,400) : ""}`;
      }catch(e){
        dom.resultToast.className="toast bad";
        dom.resultToast.textContent="送信エラー： " + (e?.message || e);
      }
    }

    /***********************
     * Map（ミニ＋詳細）
     * ・精霊（現在位置）
     * ・建物（20/40/60/80/100）
     ***********************/
    const MAP_PATH = "M42 190 C 72 176, 88 172, 106 160 C 126 146, 120 128, 140 118 C 158 109, 166 128, 184 112 C 202 96, 180 78, 200 68 C 224 56, 236 84, 258 58 C 274 38, 230 32, 196 40 C 172 46, 168 34, 160 24";

    const mapState = {
      pathLen: 0,
      initDone: false
    };

    function createMapSvg(targetSvg){
      targetSvg.innerHTML = "";
      const NS = "http://www.w3.org/2000/svg";

      const defs = document.createElementNS(NS, "defs");

      const glow = document.createElementNS(NS, "filter");
      glow.setAttribute("id", "mapGlow");
      const blur = document.createElementNS(NS, "feGaussianBlur");
      blur.setAttribute("stdDeviation", "2.0");
      blur.setAttribute("result", "b");
      const merge = document.createElementNS(NS, "feMerge");
      const m1 = document.createElementNS(NS, "feMergeNode");
      m1.setAttribute("in", "b");
      const m2 = document.createElementNS(NS, "feMergeNode");
      m2.setAttribute("in", "SourceGraphic");
      merge.appendChild(m1); merge.appendChild(m2);
      glow.appendChild(blur); glow.appendChild(merge);

      const lg = document.createElementNS(NS, "linearGradient");
      lg.setAttribute("id","mapStroke");
      lg.setAttribute("x1","0%"); lg.setAttribute("y1","0%");
      lg.setAttribute("x2","100%"); lg.setAttribute("y2","0%");
      const s1 = document.createElementNS(NS,"stop"); s1.setAttribute("offset","0%"); s1.setAttribute("stop-color","var(--accent1)");
      const s2 = document.createElementNS(NS,"stop"); s2.setAttribute("offset","55%"); s2.setAttribute("stop-color","var(--accent3)");
      const s3 = document.createElementNS(NS,"stop"); s3.setAttribute("offset","100%"); s3.setAttribute("stop-color","var(--accent2)");
      lg.appendChild(s1); lg.appendChild(s2); lg.appendChild(s3);

      defs.appendChild(glow);
      defs.appendChild(lg);
      targetSvg.appendChild(defs);

      const bg = document.createElementNS(NS,"rect");
      bg.setAttribute("x","0"); bg.setAttribute("y","0"); bg.setAttribute("width","320"); bg.setAttribute("height","220");
      bg.setAttribute("fill","rgba(255,255,255,.02)");
      targetSvg.appendChild(bg);

      const base = document.createElementNS(NS,"path");
      base.setAttribute("d", MAP_PATH);
      base.setAttribute("fill","none");
      base.setAttribute("stroke","rgba(255,255,255,.14)");
      base.setAttribute("stroke-width","6");
      base.setAttribute("stroke-linecap","round");
      base.setAttribute("stroke-linejoin","round");
      targetSvg.appendChild(base);

      const prog = document.createElementNS(NS,"path");
      prog.setAttribute("id", targetSvg.id + "_prog");
      prog.setAttribute("d", MAP_PATH);
      prog.setAttribute("fill","none");
      prog.setAttribute("stroke","url(#mapStroke)");
      prog.setAttribute("stroke-width","6");
      prog.setAttribute("stroke-linecap","round");
      prog.setAttribute("stroke-linejoin","round");
      prog.setAttribute("filter","url(#mapGlow)");
      targetSvg.appendChild(prog);

      // 建物ポイント（20刻み）
      const buildings = document.createElementNS(NS,"g");
      buildings.setAttribute("id", targetSvg.id + "_buildings");
      targetSvg.appendChild(buildings);

      // 精霊（現在位置）
      const spirit = document.createElementNS(NS,"g");
      spirit.setAttribute("id", targetSvg.id + "_spirit");
      spirit.setAttribute("filter","url(#mapGlow)");
      targetSvg.appendChild(spirit);

      // スタート/ゴール目印
      const goalText = document.createElementNS(NS,"text");
      goalText.setAttribute("x","160"); goalText.setAttribute("y","14");
      goalText.setAttribute("text-anchor","middle");
      goalText.setAttribute("font-size","10");
      goalText.setAttribute("fill","rgba(234,240,255,.78)");
      goalText.style.letterSpacing = ".12em";
      goalText.textContent = "GOAL";
      targetSvg.appendChild(goalText);

      const startText = document.createElementNS(NS,"text");
      startText.setAttribute("x","42"); startText.setAttribute("y","206");
      startText.setAttribute("text-anchor","start");
      startText.setAttribute("font-size","10");
      startText.setAttribute("fill","rgba(234,240,255,.68)");
      startText.style.letterSpacing = ".12em";
      startText.textContent = "START";
      targetSvg.appendChild(startText);
    }

    function ensureMapInit(){
      if (mapState.initDone) return;
      createMapSvg(dom.miniMapSvg);
      createMapSvg(dom.mapModalSvg);

      // path length はどちらでも同じなので modal の path で取得
      const prog = document.getElementById(dom.mapModalSvg.id + "_prog");
      mapState.pathLen = prog.getTotalLength();

      // dash設定（進捗線）
      for (const svg of [dom.miniMapSvg, dom.mapModalSvg]){
        const p = document.getElementById(svg.id + "_prog");
        p.style.strokeDasharray = `${mapState.pathLen} ${mapState.pathLen}`;
        p.style.strokeDashoffset = `${mapState.pathLen}`;
      }

      mapState.initDone = true;
      state.mapReady = true;
    }

    function pointAt(t){
      // t: 0..1
      const prog = document.getElementById(dom.mapModalSvg.id + "_prog");
      return prog.getPointAtLength(mapState.pathLen * t);
    }

    function drawBuildings(svg, doneCount){
      const NS = "http://www.w3.org/2000/svg";
      const g = document.getElementById(svg.id + "_buildings");
      g.innerHTML = "";

      const milestones = [20,40,60,80,100];
      for (const m of milestones){
        const t = m/100;
        const pt = pointAt(t);

        const lit = doneCount >= m;

        // 建物（小さな神殿）
        const temple = document.createElementNS(NS,"g");
        temple.setAttribute("transform", `translate(${pt.x},${pt.y})`);

        const roof = document.createElementNS(NS,"path");
        roof.setAttribute("d", "M -10 6 L 0 -6 L 10 6 Z");
        roof.setAttribute("fill", lit ? "rgba(255,255,255,.18)" : "rgba(255,255,255,.06)");
        roof.setAttribute("stroke", lit ? "rgba(255,255,255,.30)" : "rgba(255,255,255,.14)");
        roof.setAttribute("stroke-width","1");

        const body = document.createElementNS(NS,"rect");
        body.setAttribute("x","-8"); body.setAttribute("y","6");
        body.setAttribute("width","16"); body.setAttribute("height","12");
        body.setAttribute("rx","2");
        body.setAttribute("fill", lit ? "rgba(255,255,255,.10)" : "rgba(255,255,255,.04)");
        body.setAttribute("stroke", lit ? "rgba(255,255,255,.22)" : "rgba(255,255,255,.12)");
        body.setAttribute("stroke-width","1");

        const door = document.createElementNS(NS,"rect");
        door.setAttribute("x","-2.5"); door.setAttribute("y","10");
        door.setAttribute("width","5"); door.setAttribute("height","8");
        door.setAttribute("rx","1.5");
        door.setAttribute("fill", lit ? "rgba(207,167,110,.35)" : "rgba(255,255,255,.06)");
        door.setAttribute("stroke", lit ? "rgba(207,167,110,.55)" : "rgba(255,255,255,.12)");
        door.setAttribute("stroke-width","1");

        // ベースリング（点灯）
        const ring = document.createElementNS(NS,"circle");
        ring.setAttribute("cx","0"); ring.setAttribute("cy","10");
        ring.setAttribute("r","14");
        ring.setAttribute("fill", "rgba(0,0,0,0)");
        ring.setAttribute("stroke", lit ? "rgba(255,255,255,.26)" : "rgba(255,255,255,.10)");
        ring.setAttribute("stroke-width","1");
        ring.setAttribute("opacity", lit ? "1" : ".75");

        temple.appendChild(ring);
        temple.appendChild(roof);
        temple.appendChild(body);
        temple.appendChild(door);

        // ラベルは詳細マップだけ表示
        if (svg.id === "mapModalSvg"){
          const label = document.createElementNS(NS,"text");
          label.setAttribute("x","0"); label.setAttribute("y","-12");
          label.setAttribute("text-anchor","middle");
          label.setAttribute("font-size","10");
          label.setAttribute("fill", lit ? "rgba(234,240,255,.88)" : "rgba(234,240,255,.55)");
          label.textContent = `${m}`;
          temple.appendChild(label);
        }

        g.appendChild(temple);
      }
    }

    function drawSpirit(svg, doneCount){
      const NS = "http://www.w3.org/2000/svg";
      const g = document.getElementById(svg.id + "_spirit");
      g.innerHTML = "";

      const t = doneCount/100;
      const pt = pointAt(t);

      // 精霊本体（光球＋翼）
      const halo = document.createElementNS(NS,"circle");
      halo.setAttribute("cx", pt.x);
      halo.setAttribute("cy", pt.y);
      halo.setAttribute("r", "10");
      halo.setAttribute("fill", "rgba(255,255,255,.10)");

      const orb = document.createElementNS(NS,"circle");
      orb.setAttribute("cx", pt.x);
      orb.setAttribute("cy", pt.y);
      orb.setAttribute("r", "5.5");
      orb.setAttribute("fill", "rgba(255,255,255,.92)");
      orb.setAttribute("stroke", "rgba(255,255,255,.22)");

      const wingL = document.createElementNS(NS,"path");
      wingL.setAttribute("d", `M ${pt.x-5} ${pt.y-1} C ${pt.x-18} ${pt.y-10}, ${pt.x-22} ${pt.y+8}, ${pt.x-8} ${pt.y+6}`);
      wingL.setAttribute("fill","none");
      wingL.setAttribute("stroke","rgba(255,255,255,.22)");
      wingL.setAttribute("stroke-width","1.6");
      wingL.setAttribute("stroke-linecap","round");

      const wingR = document.createElementNS(NS,"path");
      wingR.setAttribute("d", `M ${pt.x+5} ${pt.y-1} C ${pt.x+18} ${pt.y-10}, ${pt.x+22} ${pt.y+8}, ${pt.x+8} ${pt.y+6}`);
      wingR.setAttribute("fill","none");
      wingR.setAttribute("stroke","rgba(255,255,255,.22)");
      wingR.setAttribute("stroke-width","1.6");
      wingR.setAttribute("stroke-linecap","round");

      g.appendChild(halo);
      g.appendChild(wingL);
      g.appendChild(wingR);
      g.appendChild(orb);
    }

    function updateProgressStroke(svg, doneCount){
      const pct = doneCount/100;
      const offset = mapState.pathLen * (1 - pct);
      const p = document.getElementById(svg.id + "_prog");
      p.style.strokeDashoffset = String(offset);
    }

    function updateMapAll(doneCount){
      ensureMapInit();
      for (const svg of [dom.miniMapSvg, dom.mapModalSvg]){
        updateProgressStroke(svg, doneCount);
        drawBuildings(svg, doneCount);
        drawSpirit(svg, doneCount);
      }
    }

    /***********************
     * 章クリア演出（本気版）
     * ・テーマ切替
     * ・背景バースト（--chapterPulse）
     * ・振動
     * ・モーダル
     ***********************/
    function pulseChapter(){
      document.documentElement.style.setProperty("--chapterPulse", "1");
      setTimeout(()=>document.documentElement.style.setProperty("--chapterPulse","0"), 520);
      try{ navigator.vibrate?.([25, 70, 25]); }catch{}
    }

    function ensureBadge(milestone){
      const def = BADGE_DEFS.find(b => b.milestone === milestone);
      if (!def) return;
      if (state.badges.some(b => b.milestone === milestone)) return;

      state.badges.push({
        milestone:def.milestone,
        title:def.title,
        meta:def.meta,
        desc:def.desc,
        tags:def.tags,
        at: Date.now()
      });
      save();
    }

    function maybeShowChapterClear(){
      const done = answeredDoneCount();
      const milestones = [20,40,60,80,100];
      const hit = milestones.find(m => done >= m && state.lastChapterShown < m);
      if (!hit) return;

      state.lastChapterShown = hit;
      ensureBadge(hit);
      save();

      // 演出
      pulseChapter();

      const chapIdx = Math.min(4, Math.floor((hit-1)/20));
      const nextIdx = Math.min(4, chapIdx+1);

      dom.chapterModalTitle.textContent = `CHAPTER CLEAR（${hit}/100）`;
      dom.chapterModalBody.textContent = (hit === 100)
        ? "最終章を突破しました。未回答が0なら、悩み入力→結果へ進めます。"
        : `章を突破しました。次の章（${THEMES[nextIdx].name}）へ移行します。`;

      const def = BADGE_DEFS.find(b=>b.milestone===hit);
      dom.reward1.textContent = `称号獲得：${def ? def.title : "ルーン点灯"}`;
      dom.reward2.textContent = (hit === 100)
        ? "ボーナス：結果の統合処理が解放されます。"
        : "ボーナス：配色が切り替わり、集中の持続が上がります。";

      dom.chapterModal.style.display = "flex";
      dom.chapterModal.setAttribute("aria-hidden","false");
    }

    function closeChapterModal(){
      dom.chapterModal.style.display = "none";
      dom.chapterModal.setAttribute("aria-hidden","true");
      updateMeter();
    }

    function openMapModal(){
      ensureMapInit();
      const done = answeredDoneCount();
      updateMapAll(done);
      dom.mapModalBody.textContent = `進捗：${done}/100　｜　精霊＝現在位置　｜　建物＝章ポイント（20ごと）`;
      dom.mapModal.style.display="flex";
      dom.mapModal.setAttribute("aria-hidden","false");
    }
    function closeMapModal(){
      dom.mapModal.style.display="none";
      dom.mapModal.setAttribute("aria-hidden","true");
    }

    function hideAllViews(){
      dom.viewHero.hidden=true;
      dom.viewProfile.hidden=true;
      dom.viewQuestions.hidden=true;
      dom.viewWorry.hidden=true;
      dom.viewResult.hidden=true;
    }

    function renderProfile(){
      dom.name.value = state.profile.name || "";
      dom.gender.value = state.profile.gender || "";
      dom.birthday.value = state.profile.birthday || "";
      dom.userId.value = state.userId || "";
    }

    function renderQuestion(){
      const i = state.currentIndex;
      const q = QUESTIONS[i];
      dom.qText.textContent = q.text;

      dom.qTagChip.textContent = q.tag; // 表示はCSSで非表示、データは保持
      dom.qIndexChip.textContent = `Q ${i+1} / 100`;

      const done = answeredDoneCount();
      dom.doneCountText.textContent = String(done);

      const current = Number.isInteger(state.answers[i]) ? state.answers[i] : SCALE_MID;
      dom.range.value = String(current);
      renderTicks(current);
      applyRangePaint(current);

      dom.btnPrevQ.disabled = (i===0);

      if (!allAnswered()){
        dom.btnNextQ.textContent = "次へ（未回答へ）";
      } else {
        dom.btnNextQ.textContent = (i===99) ? "次へ（悩み入力）" : "次へ";
      }
    }

    function updateWorryCount(){
      const len = dom.worryText.value.length;
      dom.worryCount.textContent = `${len} / 2000`;
    }

    function renderWorry(){
      dom.worryText.value = state.worryText || "";
      updateWorryCount();
    }

    function renderBadges(){
      if (!state.badges.length){
        dom.badgeSection.style.display="none";
        dom.badgeGrid.innerHTML="";
        return;
      }
      dom.badgeSection.style.display="block";
      dom.badgeGrid.innerHTML = "";

      const badgesSorted = [...state.badges].sort((a,b)=>a.milestone-b.milestone);
      for (const b of badgesSorted){
        const div = document.createElement("div");
        div.className = "badgeCard";

        const title = document.createElement("div");
        title.className = "badgeTitle";
        title.textContent = b.title || `称号（${b.milestone}/100）`;

        const meta = document.createElement("div");
        meta.className = "badgeMeta";
        meta.textContent = b.meta || `到達：${b.milestone}/100`;

        const desc = document.createElement("div");
        desc.className = "badgeDesc";
        desc.textContent = b.desc || "";

        const tags = document.createElement("div");
        tags.className = "badgeTagRow";
        for (const t of (b.tags || [])){
          const s = document.createElement("span");
          s.className = "badgeTag";
          s.textContent = t;
          tags.appendChild(s);
        }

        div.appendChild(title);
        div.appendChild(meta);
        if (b.desc) div.appendChild(desc);
        if ((b.tags||[]).length) div.appendChild(tags);
        dom.badgeGrid.appendChild(div);
      }
    }

    function renderResult(){
      dom.resultToast.style.display="none";
      dom.jsonPreviewWrap.style.display="none";

      renderBadges();

      if (!allAnswered()){
        const idx = firstUnansweredIndex();
        dom.resultToast.className="toast bad";
        dom.resultToast.textContent=`未回答があります（Q${idx+1}）。未回答を埋めてから結果を表示します。`;
        dom.resultToast.style.display="block";
        state.currentIndex = idx >= 0 ? idx : 0;
        save();
        setTimeout(()=> setView("questions"), 350);
        return;
      }

      let payload;
      try{ payload = buildPayload(); state.lastPayload = payload; save(); }
      catch(e){
        dom.resultToast.className="toast bad";
        dom.resultToast.textContent="結果表示前のチェックに失敗しました： " + (e?.message || e);
        dom.resultToast.style.display="block";
        return;
      }

      const scores = payload.scores;
      const code = payload.typeCode;
      const title = TYPE_TITLES[code] || "（未定義）";
      const tarot = TAROT_MAJOR[code] || "—";

      dom.resultToast.className="toast ok";
      dom.resultToast.textContent =
        `判定：${code}\n${title}\n（象徴）タロット：${tarot}\n\n` +
        `軸スコア：E ${scores.E} / S ${scores.S} / T ${scores.T} / J ${scores.J}\n\n` +
        "このまま最終送信できます。";
      dom.resultToast.style.display="block";
    }

    function renderAll(){
      hideAllViews();
      dom.bottomNav.style.display = (state.view==="questions") ? "block" : "none";

      if (state.view==="hero"){ dom.viewHero.hidden=false; }
      if (state.view==="profile"){ dom.viewProfile.hidden=false; renderProfile(); }
      if (state.view==="questions"){ dom.viewQuestions.hidden=false; renderQuestion(); }
      if (state.view==="worry"){ dom.viewWorry.hidden=false; renderWorry(); }
      if (state.view==="result"){ dom.viewResult.hidden=false; renderResult(); }

      updateMeter();
    }

    // ナビ：次へ（未回答へスキップ）
    function goNext(){
      const i = state.currentIndex;

      if (allAnswered()){
        if (i < 99){
          state.currentIndex = 99;
          save();
          renderQuestion();
          updateMeter();
          showQToast("全問回答済み。最後へ移動します。", "ok");
          return;
        }
        setView("worry");
        return;
      }

      const nxt = nextUnansweredIndex(i);
      if (nxt !== -1){
        state.currentIndex = nxt;
        save();
        renderQuestion();
        updateMeter();
        showQToast(`未回答へ移動：Q${nxt+1}`, "warn");
        return;
      }

      const first = firstUnansweredIndex();
      if (first !== -1){
        state.currentIndex = first;
        save();
        renderQuestion();
        updateMeter();
        showQToast(`未回答が残っています：Q${first+1}へ`, "warn");
        return;
      }
    }

    dom.btnStart.addEventListener("click", ()=> setView("profile"));
    dom.btnResetAll.addEventListener("click", clearAll);
    dom.btnBackToHero.addEventListener("click", ()=> setView("hero"));

    dom.btnToQuestions.addEventListener("click", ()=>{
      if (!validateProfile()) return;
      syncProfileFromInputs();
      ensureMapInit();
      setView("questions");
    });

    dom.name.addEventListener("input", syncProfileFromInputs);
    dom.gender.addEventListener("change", syncProfileFromInputs);
    dom.birthday.addEventListener("change", syncProfileFromInputs);
    dom.userId.addEventListener("input", syncProfileFromInputs);

    dom.btnResetFromQuestions.addEventListener("click", clearAll);
    dom.btnResetFromResult.addEventListener("click", clearAll);

    dom.btnJumpProfile.addEventListener("click", ()=> setView("profile"));
    dom.btnJumpFirstUnanswered.addEventListener("click", ()=>{
      const idx = firstUnansweredIndex();
      if (idx === -1){
        showQToast("未回答はありません。", "ok");
        return;
      }
      state.currentIndex = idx;
      save();
      renderQuestion();
      updateMeter();
      showQToast(`未回答へ移動：Q${idx+1}`, "warn");
    });

    dom.range.addEventListener("input", ()=>{
      const v = clamp(Number(dom.range.value), SCALE_MIN, SCALE_MAX);
      setAnswerValue(v, true);
    });

    dom.btnPrevQ.addEventListener("click", ()=>{
      if (state.currentIndex>0){
        state.currentIndex--;
        save();
        renderQuestion();
        updateMeter();
      }
    });
    dom.btnNextQ.addEventListener("click", goNext);

    dom.btnChapterContinue.addEventListener("click", closeChapterModal);
    dom.chapterModal.addEventListener("click", (e)=>{ if (e.target===dom.chapterModal) closeChapterModal(); });

    dom.worryText.addEventListener("input", ()=>{
      state.worryText = dom.worryText.value.slice(0,2000);
      updateWorryCount();
      save();
    });

    dom.btnShowResult.addEventListener("click", ()=>{
      if (!allAnswered()){
        const idx = firstUnansweredIndex();
        state.currentIndex = idx >= 0 ? idx : 0;
        save();
        setView("questions");
        return;
      }
      setView("result");
    });

    dom.btnFinalSubmit.addEventListener("click", finalSubmit);

    dom.btnCopyJson.addEventListener("click", async ()=>{
      let payload = state.lastPayload;
      if (!payload){
        try{ payload = buildPayload(); state.lastPayload = payload; save(); }
        catch(e){
          dom.resultToast.className="toast bad";
          dom.resultToast.textContent="JSON生成に失敗しました： " + (e?.message || e);
          dom.resultToast.style.display="block";
          return;
        }
      }
      const ok = await copyToClipboard(safeJson(payload));
      dom.resultToast.className = "toast " + (ok ? "ok" : "bad");
      dom.resultToast.textContent = ok ? "JSONをコピーしました。" : "コピーに失敗しました。";
      dom.resultToast.style.display="block";
    });

    dom.btnDownloadJson.addEventListener("click", ()=>{
      let payload = state.lastPayload;
      if (!payload){
        try{ payload = buildPayload(); state.lastPayload = payload; save(); }
        catch(e){
          dom.resultToast.className="toast bad";
          dom.resultToast.textContent="JSON生成に失敗しました： " + (e?.message || e);
          dom.resultToast.style.display="block";
          return;
        }
      }
      downloadText("fortuneai_final_submit.json", safeJson(payload));
      dom.resultToast.className="toast ok";
      dom.resultToast.textContent="JSONをダウンロードしました。";
      dom.resultToast.style.display="block";
    });

    // 地図：常時（ミニ）＋詳細（モーダル）
    dom.miniMap.addEventListener("click", openMapModal);
    dom.btnOpenMap.addEventListener("click", openMapModal);
    dom.btnOpenMap2.addEventListener("click", openMapModal);
    dom.btnCloseMap.addEventListener("click", closeMapModal);
    dom.mapModal.addEventListener("click", (e)=>{ if (e.target===dom.mapModal) closeMapModal(); });

    /***********************
     * Boot
     ***********************/
    (function init(){
      const q = parseQuery();
      if (q.userId) state.userId = q.userId;

      const restored = load();
      if (restored){
        if (q.userId) state.userId = q.userId;
        dom.profileRestoreNote.style.display="block";
        setTimeout(()=> dom.profileRestoreNote.style.display="none", 2500);
      }

      ensureMapInit();
      renderAll();
    })();
  </script>
</body>
</html>
